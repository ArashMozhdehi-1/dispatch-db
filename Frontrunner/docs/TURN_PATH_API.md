# Turn Path API Documentation

## Overview

The Turn Path API computes G2-style (curvature-constrained) turning paths between two roads at a shared intersection. It uses **Dubins paths** to generate smooth curves that respect vehicle dimensions and turning constraints, ensuring the vehicle envelope stays within the intersection polygon.

## Architecture

### Components

1. **Vehicle Profiles** (`lib/vehicle_profiles.py`)
   - Pre-defined profiles for common haul trucks (Komatsu 830E, 930E, CAT 797F)
   - Custom profile support

2. **Dubins Path Solver** (`lib/dubins_path.py`)
   - Pure Python implementation of Dubins path algorithm
   - Computes shortest path with bounded curvature
   - Supports 6 path types: LSL, RSR, LSR, RSL, RLR, LRL

3. **Turn Path Logic** (`lib/turn_path_api.py`)
   - Fetches side-center points from database
   - Computes approach headings
   - Generates paths and validates clearance

4. **CLI Interface** (`etl/compute_turn_path_cli.py`)
   - Command-line tool for path computation
   - Called by Next.js API via subprocess

5. **REST API** (`pages/api/turn-path.js`, `pages/api/vehicle-profiles.js`)
   - HTTP endpoints for frontend integration

---

## API Endpoints

### 1. List Vehicle Profiles

**GET** `/api/vehicle-profiles`

Returns all available pre-defined vehicle profiles.

**Response:**
```json
{
  "status": "ok",
  "profiles": {
    "komatsu_830e": {
      "name": "Komatsu 830E",
      "vehicle_width_m": 7.3,
      "wheelbase_m": 6.35,
      "max_steering_angle_deg": 32.0,
      "side_buffer_m": 0.5,
      "front_buffer_m": 1.0,
      "rear_buffer_m": 1.0,
      "min_turn_radius_m": 10.18,
      "total_width_with_buffer_m": 8.3
    },
    "komatsu_930e": { ... },
    "cat_797f": { ... }
  }
}
```

---

### 2. Compute Turn Path

**POST** `/api/turn-path`

Computes a turning path between two roads at an intersection.

**Request Body:**
```json
{
  "from_road_id": "INT_18 -> 480_RL",      // Source road ID
  "to_road_id": "480_RL -> INT_18",        // Destination road ID
  "intersection_name": "INT_18",           // Intersection name
  "vehicle_profile_id": "komatsu_830e",    // Optional, default: komatsu_830e
  "sampling_step_m": 1.0,                  // Optional, default: 1.0
  "local_srid": 28350                      // Optional, default: 28350 (GDA2020 MGA50)
}
```

**Custom Vehicle Profile:**
```json
{
  "from_road_id": "INT_18 -> 480_RL",
  "to_road_id": "480_RL -> INT_18",
  "intersection_name": "INT_18",
  "custom_vehicle_profile": {
    "name": "Custom Truck",
    "vehicle_width_m": 8.0,
    "wheelbase_m": 7.0,
    "max_steering_angle_deg": 30.0,
    "side_buffer_m": 0.5,
    "front_buffer_m": 1.0,
    "rear_buffer_m": 1.0
  },
  "sampling_step_m": 0.5
}
```

**Response (Success):**
```json
{
  "status": "ok",
  "from_road_id": "INT_18 -> 480_RL",
  "to_road_id": "480_RL -> INT_18",
  "intersection_name": "INT_18",
  "vehicle": {
    "name": "Komatsu 830E",
    "vehicle_width_m": 7.3,
    "min_turn_radius_m": 10.18,
    ...
  },
  "path": {
    "wkt": "LINESTRING(119.xxx -22.xxx, ...)",
    "geojson": {
      "type": "LineString",
      "coordinates": [[119.xxx, -22.xxx], ...]
    },
    "path_type": "LSR",
    "length_m": 35.2,
    "num_points": 36,
    "sampling_step_m": 1.0
  },
  "clearance": {
    "vehicle_envelope_ok": true,
    "outside_area_sqm": 0.0,
    "min_clearance_m": 1.23,
    "envelope_wkt": "POLYGON(...)",
    "vehicle_width_with_buffer_m": 8.3,
    "min_turn_radius_m": 10.18
  },
  "debug": {
    "from_point_local": [410123.45, 7473456.78],
    "to_point_local": [410145.67, 7473478.90],
    "from_heading_deg": 45.3,
    "to_heading_deg": -134.7,
    "local_srid": 28350
  }
}
```

**Response (Error):**
```json
{
  "status": "error",
  "error": "Could not find side-center points for roads ... at intersection ..."
}
```

---

## How It Works

### 1. Side-Center Points

The system uses **side-center markers** generated by `generate_road_corner_points.py`. For each road:
- 2 side-center points are computed (one on each "width" edge)
- Points are positioned at the midpoint of the edge that overlaps the intersection
- Stored in `map_location` table with type `road_corner_side_center`

### 2. Heading Computation

For each road at the intersection:
- Extract the "width edge" geometry from `segment_wkt`
- Compute road tangent (perpendicular to width edge)
- Orient tangent toward/away from intersection centroid

### 3. Dubins Path Generation

Given:
- Start pose: `(x_from, y_from, θ_from)`
- Goal pose: `(x_to, y_to, θ_to)`
- Min turning radius: `R = wheelbase / tan(max_steering_angle)`

The algorithm:
1. Transforms the problem to a normalized frame (R=1)
2. Evaluates all 6 Dubins path types (LSL, RSR, LSR, RSL, RLR, LRL)
3. Selects the shortest feasible path
4. Samples the path to a polyline with specified step size

### 4. Clearance Validation

The system checks if the **vehicle envelope** (path buffered by vehicle half-width + side buffer) stays within the intersection polygon:

```sql
WITH envelope AS (
  SELECT ST_Buffer(path_geom, (vehicle_width/2 + side_buffer)) AS geom
),
outside AS (
  SELECT ST_Difference(envelope.geom, intersection.geom) AS geom
)
SELECT ST_Area(outside.geom) AS outside_area_sqm;
```

- `outside_area_sqm ≈ 0` → ✅ Vehicle stays inside
- `outside_area_sqm > 0` → ❌ Vehicle would leave intersection

---

## Vehicle Parameters

### Key Parameters

| Parameter | Description | Units |
|-----------|-------------|-------|
| `vehicle_width_m` | Overall width of vehicle | meters |
| `wheelbase_m` | Distance between front and rear axles | meters |
| `max_steering_angle_deg` | Maximum steering angle | degrees |
| `side_buffer_m` | Safety clearance on left/right | meters |
| `front_buffer_m` | Safety clearance in front (future use) | meters |
| `rear_buffer_m` | Safety clearance behind (future use) | meters |

### Derived Values

```python
min_turn_radius_m = wheelbase_m / tan(radians(max_steering_angle_deg))
total_width_with_buffer_m = vehicle_width_m + 2 * side_buffer_m
```

### Pre-defined Profiles

| Profile | Width | Wheelbase | Max Steer | Min Radius |
|---------|-------|-----------|-----------|------------|
| **Komatsu 830E** | 7.3 m | 6.35 m | 32° | 10.2 m |
| **Komatsu 930E** | 8.5 m | 7.0 m | 30° | 12.1 m |
| **CAT 797F** | 9.5 m | 7.7 m | 28° | 14.5 m |

---

## Usage Examples

### Example 1: Frontend Integration (React)

```javascript
// Fetch available profiles
const profilesRes = await fetch('/api/vehicle-profiles');
const { profiles } = await profilesRes.json();

// Compute turn path
const pathRes = await fetch('/api/turn-path', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({
    from_road_id: selectedFromRoad.road_id,
    to_road_id: selectedToRoad.road_id,
    intersection_name: sharedIntersection.name,
    vehicle_profile_id: 'komatsu_830e',
    sampling_step_m: 1.0
  })
});

const { path, clearance } = await pathRes.json();

// Render path on Cesium map
const pathEntity = cesiumViewer.entities.add({
  polyline: {
    positions: Cesium.Cartesian3.fromDegreesArray(
      path.geojson.coordinates.flat()
    ),
    width: 3,
    material: clearance.vehicle_envelope_ok
      ? Cesium.Color.GREEN
      : Cesium.Color.RED
  }
});
```

### Example 2: Python CLI

```bash
# List profiles
python etl/compute_turn_path_cli.py list-profiles

# Compute path (input via stdin)
echo '{
  "from_road_id": "INT_18 -> 480_RL",
  "to_road_id": "480_RL -> INT_18",
  "intersection_name": "INT_18",
  "vehicle_profile_id": "komatsu_830e"
}' | python etl/compute_turn_path_cli.py compute
```

### Example 3: cURL

```bash
# List profiles
curl http://localhost:3001/api/vehicle-profiles

# Compute path
curl -X POST http://localhost:3001/api/turn-path \
  -H "Content-Type: application/json" \
  -d '{
    "from_road_id": "INT_18 -> 480_RL",
    "to_road_id": "480_RL -> INT_18",
    "intersection_name": "INT_18",
    "vehicle_profile_id": "komatsu_830e",
    "sampling_step_m": 0.5
  }'
```

---

## Database Schema

### Side-Center Points (`map_location`)

```sql
SELECT
  _oid_,
  name,
  type,  -- 'road_corner_side_center'
  geometry_wkt,  -- POINT geometry
  road_marker_metadata  -- JSONB with:
    -- 'road_id': Road identifier
    -- 'road_name': Human-readable road name
    -- 'overlapping_entity_name': Intersection name
    -- 'segment_wkt': LINESTRING of the width edge
    -- 'center_lon', 'center_lat': Coordinates
    -- 'road_width_m', 'road_length_m': Road dimensions
FROM map_location
WHERE type = 'road_corner_side_center'
  AND road_marker_metadata->>'road_id' = 'INT_18 -> 480_RL'
  AND road_marker_metadata->>'overlapping_entity_name' = 'INT_18';
```

### Intersection Polygons (`map_location`)

```sql
SELECT
  _oid_,
  name,
  type,  -- 'intersection_polygon' or 'Intersection'
  geometry_wkt  -- POLYGON geometry
FROM map_location
WHERE type IN ('intersection_polygon', 'Intersection')
  AND name = 'INT_18';
```

---

## Coordinate Systems

### SRID Usage

- **Input/Output (API):** EPSG:4326 (WGS84 lat/lon)
- **Internal Computation:** EPSG:28350 (GDA2020 / MGA zone 50)
  - Metric units required for distance/buffer calculations
  - Configurable via `local_srid` parameter

### Coordinate Transformations

```sql
-- WGS84 → Local metric SRID (for computation)
ST_Transform(geometry_wkt, 28350)

-- Local SRID → WGS84 (for API response)
ST_Transform(ST_GeomFromText(path_wkt_local, 28350), 4326)
```

---

## Future Enhancements

1. **G2 Clothoids**: Replace Dubins paths with true G2-continuous clothoid curves
2. **Obstacle Avoidance**: Check for obstacles within the intersection
3. **Multi-segment Paths**: Support paths through multiple intersections
4. **Speed Profiles**: Generate speed/acceleration profiles along the path
5. **Path Smoothing**: Apply smoothing filters to reduce jerk
6. **Visualization**: Add 3D visualization of vehicle envelope in Cesium
7. **Batch Processing**: Compute paths for multiple road pairs simultaneously
8. **Caching**: Cache computed paths for frequently-used road pairs

---

## Troubleshooting

### Common Errors

**"Could not find side-center points"**
- Ensure roads have been processed by `generate_road_corner_points.py`
- Check that road IDs match exactly (case-sensitive)
- Verify intersection name exists in database

**"vehicle_envelope_ok: false"**
- Try reducing `side_buffer_m`
- Check if intersection polygon is too small
- Consider using a smaller vehicle profile

**"Python script failed"**
- Check Docker logs: `docker logs frontrunner_backend`
- Ensure Python dependencies are installed in container
- Verify database connection parameters

### Debug Mode

Enable debug output by checking the `debug` field in the API response:

```json
"debug": {
  "from_point_local": [410123.45, 7473456.78],
  "from_heading_deg": 45.3,
  ...
}
```

---

## References

- **Dubins Paths**: L. E. Dubins (1957). "On Curves of Minimal Length with a Constraint on Average Curvature"
- **Vehicle Specifications**: Komatsu/Caterpillar technical datasheets
- **PostGIS**: https://postgis.net/docs/
- **GDA2020 MGA50**: EPSG:28350

