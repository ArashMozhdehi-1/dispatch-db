"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["components_MapComponent_js"],{

/***/ "./components/MapComponent.js":
/*!************************************!*\
  !*** ./components/MapComponent.js ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ MapComponent; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @swc/helpers/_/_tagged_template_literal */ \"./node_modules/@swc/helpers/esm/_tagged_template_literal.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _apollo_client__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @apollo/client */ \"./node_modules/@apollo/client/index.js\");\n\nfunction _templateObject() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"\\n  query GetLocations {\\n    locations {\\n      location_id\\n      location_name\\n      latitude\\n      longitude\\n      elevation_m\\n      unit_type\\n      location_category\\n      pit_name\\n      region_name\\n    }\\n  }\\n\"\n    ]);\n    _templateObject = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject1() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"\\n  query GetSegments($limit: Int) {\\n    segments(limit: $limit) {\\n      lane_id\\n      road_id\\n      direction\\n      length_m\\n      time_empty_seconds\\n      time_loaded_seconds\\n      is_closed\\n      geometry\\n      start_latitude\\n      start_longitude\\n      end_latitude\\n      end_longitude\\n    }\\n  }\\n\"\n    ]);\n    _templateObject1 = function() {\n        return data;\n    };\n    return data;\n}\n\nvar _s = $RefreshSig$();\n\n\n\n// GraphQL queries\nconst GET_LOCATIONS = (0,_apollo_client__WEBPACK_IMPORTED_MODULE_3__.gql)(_templateObject());\nconst GET_SEGMENTS = (0,_apollo_client__WEBPACK_IMPORTED_MODULE_3__.gql)(_templateObject1());\nfunction MapComponent() {\n    var _locationsData_locations, _segmentsData_segments;\n    _s();\n    const mapRef = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)(null);\n    const mapInstanceRef = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)(null);\n    const mapInitializedRef = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)(false);\n    const { data: locationsData, loading: locationsLoading, error: locationsError } = (0,_apollo_client__WEBPACK_IMPORTED_MODULE_3__.useQuery)(GET_LOCATIONS, {\n        fetchPolicy: \"cache-and-network\",\n        errorPolicy: \"all\"\n    });\n    const { data: segmentsData, loading: segmentsLoading, error: segmentsError } = (0,_apollo_client__WEBPACK_IMPORTED_MODULE_3__.useQuery)(GET_SEGMENTS, {\n        variables: {\n            limit: 100000\n        },\n        fetchPolicy: \"cache-and-network\",\n        errorPolicy: \"all\"\n    });\n    const loading = locationsLoading || segmentsLoading;\n    const error = locationsError || segmentsError;\n    const resetComponentState = ()=>{\n        mapInitializedRef.current = false;\n        if (mapInstanceRef.current) {\n            mapInstanceRef.current.remove();\n            mapInstanceRef.current = null;\n        }\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(()=>{\n        resetComponentState();\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(()=>{\n        if (false) {}\n        mapInitializedRef.current = false;\n        const loadMap = async ()=>{\n            const L = (await __webpack_require__.e(/*! import() */ \"node_modules_leaflet_dist_leaflet-src_js\").then(__webpack_require__.t.bind(__webpack_require__, /*! leaflet */ \"./node_modules/leaflet/dist/leaflet-src.js\", 23))).default;\n            let mapContainer = null;\n            let retries = 0;\n            const maxRetries = 10;\n            while(!mapContainer && retries < maxRetries){\n                await new Promise((resolve)=>setTimeout(resolve, 200));\n                mapContainer = document.getElementById(\"map\");\n                if (!mapContainer) {\n                    console.log(\"Map container not found, retrying... (\".concat(retries + 1, \"/\").concat(maxRetries, \")\"));\n                    retries++;\n                }\n            }\n            if (!mapContainer) {\n                console.error(\"Map container not found after all retries\");\n                return;\n            }\n            console.log(\"✅ Map container found, initializing map...\");\n            if (mapInstanceRef.current) {\n                console.log(\"Removing existing map...\");\n                mapInstanceRef.current.remove();\n                mapInstanceRef.current = null;\n            }\n            if (mapContainer && mapContainer._leaflet_id) {\n                console.log(\"Clearing existing leaflet ID...\");\n                delete mapContainer._leaflet_id;\n            }\n            const map = L.map(\"map\", {\n                center: [\n                    -23.5,\n                    148.5\n                ],\n                crs: L.CRS.EPSG3857,\n                zoom: 12,\n                zoomControl: true,\n                preferCanvas: false\n            });\n            mapInstanceRef.current = map;\n            mapInitializedRef.current = true;\n            console.log(\"✅ Map initialized successfully\");\n            window.map = map;\n            window.m_bezier = map;\n            const tile_layer_86af411fcaa14b2e8914466b52009633 = L.tileLayer(\"https://api.mapbox.com/styles/v1/mapbox/satellite-streets-v11/tiles/{z}/{x}/{y}?access_token=pk.eyJ1IjoiY291cHN0ZXI3NCIsImEiOiJja2xwdjRwaWYwc2Q2Mm9sYmprbzhueng2In0.p-FbkbBhJWBKW-evWZfmgw\", {\n                minZoom: 0,\n                maxZoom: 18,\n                maxNativeZoom: 18,\n                noWrap: false,\n                attribution: \"Mapbox\",\n                subdomains: \"abc\",\n                detectRetina: false,\n                tms: false,\n                opacity: 1\n            });\n            tile_layer_86af411fcaa14b2e8914466b52009633.addTo(map);\n            const tile_layer_651c217e91599c788c1d2f4ddcee22ef = L.tileLayer(\"https://api.mapbox.com/styles/v1/mapbox/outdoors-v11/tiles/{z}/{x}/{y}?access_token=pk.eyJ1IjoiY291cHN0ZXI3NCIsImEiOiJja2xwdjRwaWYwc2Q2Mm9sYmprbzhueng2In0.p-FbkbBhJWBKW-evWZfmgw\", {\n                minZoom: 0,\n                maxZoom: 18,\n                maxNativeZoom: 18,\n                noWrap: false,\n                attribution: \"Mapbox\",\n                subdomains: \"abc\",\n                detectRetina: false,\n                tms: false,\n                opacity: 1\n            });\n            const tile_layer_1aea0a94978ecf4d7f1ce0096a692741 = L.tileLayer(\"https://api.mapbox.com/styles/v1/mapbox/streets-v11/tiles/{z}/{x}/{y}?access_token=pk.eyJ1IjoiY291cHN0ZXI3NCIsImEiOiJja2xwdjRwaWYwc2Q2Mm9sYmprbzhueng2In0.p-FbkbBhJWBKW-evWZfmgw\", {\n                minZoom: 0,\n                maxZoom: 18,\n                maxNativeZoom: 18,\n                noWrap: false,\n                attribution: \"Mapbox\",\n                subdomains: \"abc\",\n                detectRetina: false,\n                tms: false,\n                opacity: 1\n            });\n            const tile_layer_bdb278bfd7bf45bd3f1b7e3f12a6fdd3 = L.tileLayer(\"https://api.mapbox.com/styles/v1/mapbox/satellite-v9/tiles/{z}/{x}/{y}?access_token=pk.eyJ1IjoiY291cHN0ZXI3NCIsImEiOiJja2xwdjRwaWYwc2Q2Mm9sYmprbzhueng2In0.p-FbkbBhJWBKW-evWZfmgw\", {\n                minZoom: 0,\n                maxZoom: 22,\n                maxNativeZoom: 22,\n                noWrap: false,\n                attribution: \"Mapbox\",\n                subdomains: \"abc\",\n                detectRetina: false,\n                tms: false,\n                opacity: 1\n            });\n            const tile_layer_ef915ab92e0ddcb9e840955a9d4420f5 = L.tileLayer(\"https://api.mapbox.com/styles/v1/mapbox/standard/tiles/{z}/{x}/{y}@2x?access_token=pk.eyJ1IjoiY291cHN0ZXI3NCIsImEiOiJja2xwdjRwaWYwc2Q2Mm9sYmprbzhueng2In0.p-FbkbBhJWBKW-evWZfmgw\", {\n                minZoom: 0,\n                maxZoom: 22,\n                maxNativeZoom: 22,\n                noWrap: false,\n                attribution: \"Mapbox\",\n                subdomains: \"abc\",\n                detectRetina: false,\n                tms: false,\n                opacity: 1\n            });\n            const tile_layer_ec0e266dacdd9ae8792153e00204f440 = L.tileLayer(\"https://api.mapbox.com/styles/v1/mapbox/dark-v10/tiles/{z}/{x}/{y}?access_token=pk.eyJ1IjoiY291cHN0ZXI3NCIsImEiOiJja2xwdjRwaWYwc2Q2Mm9sYmprbzhueng2In0.p-FbkbBhJWBKW-evWZfmgw\", {\n                minZoom: 0,\n                maxZoom: 22,\n                maxNativeZoom: 22,\n                noWrap: false,\n                attribution: \"Mapbox\",\n                subdomains: \"abc\",\n                detectRetina: false,\n                tms: false,\n                opacity: 1\n            });\n            const tile_layer_980b7691b39ace86f5bc5a9b1a738389 = L.tileLayer(\"https://api.mapbox.com/styles/v1/mapbox/navigation-night-v1/tiles/{z}/{x}/{y}?access_token=pk.eyJ1IjoiY291cHN0ZXI3NCIsImEiOiJja2xwdjRwaWYwc2Q2Mm9sYmprbzhueng2In0.p-FbkbBhJWBKW-evWZfmgw\", {\n                minZoom: 0,\n                maxZoom: 22,\n                maxNativeZoom: 22,\n                noWrap: false,\n                attribution: \"Mapbox\",\n                subdomains: \"abc\",\n                detectRetina: false,\n                tms: false,\n                opacity: 1\n            });\n            const tile_layer_4378b744272a22f78c14c9e80b830eb8 = L.tileLayer(\"https://api.mapbox.com/styles/v1/mapbox/dark-v10/tiles/{z}/{x}/{y}?access_token=pk.eyJ1IjoiY291cHN0ZXI3NCIsImEiOiJja2xwdjRwaWYwc2Q2Mm9sYmprbzhueng2In0.p-FbkbBhJWBKW-evWZfmgw\", {\n                minZoom: 0,\n                maxZoom: 22,\n                maxNativeZoom: 22,\n                noWrap: false,\n                attribution: \"Mapbox\",\n                subdomains: \"abc\",\n                detectRetina: false,\n                tms: false,\n                opacity: 1\n            });\n            const baseLayers = {\n                \"Satellite Streets\": tile_layer_86af411fcaa14b2e8914466b52009633,\n                \"Topographic\": tile_layer_651c217e91599c788c1d2f4ddcee22ef,\n                \"Streets\": tile_layer_1aea0a94978ecf4d7f1ce0096a692741,\n                \"Satellite\": tile_layer_bdb278bfd7bf45bd3f1b7e3f12a6fdd3,\n                \"Standard\": tile_layer_ef915ab92e0ddcb9e840955a9d4420f5,\n                \"Dark\": tile_layer_ec0e266dacdd9ae8792153e00204f440,\n                \"Topographic Dark\": tile_layer_980b7691b39ace86f5bc5a9b1a738389,\n                \"Streets Dark\": tile_layer_4378b744272a22f78c14c9e80b830eb8\n            };\n            const layerControl = L.control.layers(baseLayers, {}, {\n                position: \"topleft\",\n                collapsed: true\n            }).addTo(map);\n            setTimeout(()=>{\n                const layerControlElement = document.querySelector(\".leaflet-control-layers\");\n                if (layerControlElement) {\n                    let isDragging = false;\n                    let currentX;\n                    let currentY;\n                    let initialX;\n                    let initialY;\n                    let xOffset = 0;\n                    let yOffset = 0;\n                    layerControlElement.addEventListener(\"mousedown\", dragStart);\n                    document.addEventListener(\"mousemove\", drag);\n                    document.addEventListener(\"mouseup\", dragEnd);\n                    function dragStart(e) {\n                        if (e.target.closest(\".leaflet-control-layers-expanded\")) return; // Don't drag when dropdown is open\n                        initialX = e.clientX - xOffset;\n                        initialY = e.clientY - yOffset;\n                        if (e.target === layerControlElement || layerControlElement.contains(e.target)) {\n                            isDragging = true;\n                            layerControlElement.style.cursor = \"grabbing\";\n                        }\n                    }\n                    function drag(e) {\n                        if (isDragging) {\n                            e.preventDefault();\n                            currentX = e.clientX - initialX;\n                            currentY = e.clientY - initialY;\n                            xOffset = currentX;\n                            yOffset = currentY;\n                            layerControlElement.style.transform = \"translate3d(\".concat(currentX, \"px, \").concat(currentY, \"px, 0)\");\n                        }\n                    }\n                    function dragEnd(e) {\n                        initialX = currentX;\n                        initialY = currentY;\n                        isDragging = false;\n                        layerControlElement.style.cursor = \"move\";\n                    }\n                }\n            }, 100);\n            setTimeout(()=>{\n                const style = document.createElement(\"style\");\n                style.textContent = '\\n          .leaflet-control-zoom {\\n            background-color: rgba(60, 60, 60, 0.9) !important;\\n            border: 1px solid rgba(120, 120, 120, 0.5) !important;\\n            border-radius: 6px !important;\\n            box-shadow: 0 2px 8px rgba(0,0,0,0.3) !important;\\n          }\\n\\n          .leaflet-control-zoom a {\\n            background-color: rgba(60, 60, 60, 0.9) !important;\\n            color: white !important;\\n            border: none !important;\\n            font-weight: bold !important;\\n            text-shadow: 0 1px 2px rgba(0,0,0,0.5) !important;\\n          }\\n\\n          .leaflet-control-zoom a:hover {\\n            background-color: rgba(80, 80, 80, 0.9) !important;\\n            color: #bdc3c7 !important;\\n          }\\n\\n          .leaflet-control-layers {\\n            position: fixed !important;\\n            top: 20px !important;\\n            left: 50% !important;\\n            transform: translateX(-50%) !important;\\n            background-color: rgba(60, 60, 60, 0.9) !important;\\n            border: 1px solid rgba(120, 120, 120, 0.5) !important;\\n            border-radius: 6px !important;\\n            box-shadow: 0 4px 12px rgba(0,0,0,0.4) !important;\\n            backdrop-filter: blur(10px) !important;\\n            z-index: 1000 !important;\\n            cursor: move !important;\\n            min-width: 120px !important;\\n            max-width: 200px !important;\\n          }\\n\\n          .leaflet-control-layers-toggle {\\n            background-color: rgba(60, 60, 60, 0.9) !important;\\n            border: 1px solid rgba(120, 120, 120, 0.5) !important;\\n            border-radius: 6px !important;\\n            color: white !important;\\n            font-weight: 600 !important;\\n            text-transform: uppercase !important;\\n            font-size: 10px !important;\\n            padding: 6px 8px !important;\\n            min-width: 100px !important;\\n            text-align: center !important;\\n            display: flex !important;\\n            align-items: center !important;\\n            justify-content: space-between !important;\\n            cursor: move !important;\\n          }\\n\\n          .leaflet-control-layers-toggle::before {\\n            content: \"\\uD83D\\uDDFA️\" !important;\\n            margin-right: 4px !important;\\n            font-size: 12px !important;\\n          }\\n\\n          .leaflet-control-layers-toggle::after {\\n            content: \"▼\" !important;\\n            margin-left: 4px !important;\\n            font-size: 8px !important;\\n            transition: transform 0.3s ease !important;\\n          }\\n\\n          .leaflet-control-layers-expanded {\\n            background-color: rgba(255, 255, 255, 0.95) !important;\\n            color: #333 !important;\\n            border: 1px solid rgba(200, 200, 200, 0.8) !important;\\n            border-radius: 6px !important;\\n            box-shadow: 0 4px 12px rgba(0,0,0,0.3) !important;\\n            backdrop-filter: blur(10px) !important;\\n            margin-top: 4px !important;\\n            padding: 6px 0 !important;\\n            min-width: 120px !important;\\n            max-width: 200px !important;\\n          }\\n\\n          .leaflet-control-layers label {\\n            color: #333 !important;\\n            padding: 4px 8px !important;\\n            margin: 0 !important;\\n            font-size: 11px !important;\\n            cursor: pointer !important;\\n            transition: background-color 0.2s ease !important;\\n          }\\n\\n          .leaflet-control-layers label:hover {\\n            background-color: rgba(60, 60, 60, 0.1) !important;\\n          }\\n\\n          .leaflet-control-layers input[type=\"radio\"] {\\n            accent-color: #3498db !important;\\n            margin-right: 8px !important;\\n          }\\n\\n          .leaflet-control-attribution {\\n            background-color: rgba(60, 60, 60, 0.8) !important;\\n            color: #bdc3c7 !important;\\n            border: 1px solid rgba(120, 120, 120, 0.3) !important;\\n            border-radius: 4px !important;\\n            font-size: 11px !important;\\n          }\\n        ';\n                document.head.appendChild(style);\n            }, 100);\n            let isRightClicking = false;\n            let startX, startY;\n            map.getContainer().addEventListener(\"contextmenu\", function(e) {\n                e.preventDefault();\n                isRightClicking = true;\n                startX = e.clientX;\n                startY = e.clientY;\n                document.body.style.cursor = \"grabbing\";\n            });\n            map.getContainer().addEventListener(\"mousemove\", function(e) {\n                if (isRightClicking) {\n                    const deltaX = e.clientX - startX;\n                    const deltaY = e.clientY - startY;\n                    const bearingChange = deltaX * 0.5;\n                    const pitchChange = deltaY * 0.1;\n                    const currentBearing = map.getBearing ? map.getBearing() : 0;\n                    const newBearing = (currentBearing + bearingChange) % 360;\n                    if (map.setBearing) {\n                        map.setBearing(newBearing);\n                    }\n                    if (map.setPitch) {\n                        const currentPitch = map.getPitch ? map.getPitch() : 0;\n                        const newPitch = Math.max(0, Math.min(60, currentPitch + pitchChange));\n                        map.setPitch(newPitch);\n                    }\n                    startX = e.clientX;\n                    startY = e.clientY;\n                }\n            });\n            map.getContainer().addEventListener(\"mouseup\", function(e) {\n                if (isRightClicking) {\n                    isRightClicking = false;\n                    document.body.style.cursor = \"\";\n                }\n            });\n            map.getContainer().addEventListener(\"dblclick\", function(e) {\n                e.preventDefault();\n                if (map.setBearing) {\n                    map.setBearing(0);\n                }\n                if (map.setPitch) {\n                    map.setPitch(0);\n                }\n            });\n        };\n        loadMap();\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(()=>{\n        var _locationsData_locations, _segmentsData_segments;\n        console.log(\"Data check:\", {\n            mapReady: !!mapInstanceRef.current,\n            locationsData: (locationsData === null || locationsData === void 0 ? void 0 : (_locationsData_locations = locationsData.locations) === null || _locationsData_locations === void 0 ? void 0 : _locationsData_locations.length) || 0,\n            segmentsData: (segmentsData === null || segmentsData === void 0 ? void 0 : (_segmentsData_segments = segmentsData.segments) === null || _segmentsData_segments === void 0 ? void 0 : _segmentsData_segments.length) || 0,\n            loading,\n            error: !!error\n        });\n        if (!mapInstanceRef.current) {\n            console.log(\"❌ Map not ready yet\");\n            return;\n        }\n        if (loading) {\n            console.log(\"⏳ Data still loading...\");\n            return;\n        }\n        if (error) {\n            console.error(\"❌ GraphQL error:\", error);\n            return;\n        }\n        if (!(locationsData === null || locationsData === void 0 ? void 0 : locationsData.locations)) {\n            console.log(\"❌ No locations data\");\n            return;\n        }\n        if (!(segmentsData === null || segmentsData === void 0 ? void 0 : segmentsData.segments)) {\n            console.log(\"❌ No segments data\");\n            return;\n        }\n        console.log(\"✅ All data ready, processing...\");\n        console.log(\"\\uD83D\\uDCCD Locations data:\", locationsData.locations.length, \"locations\");\n        console.log(\"\\uD83D\\uDEE3️ Segments data:\", segmentsData.segments.length, \"segments\");\n        const map = mapInstanceRef.current;\n        const L = window.L;\n        map.eachLayer((layer)=>{\n            if (layer.options && (layer.options.isDataLayer || layer.options.isLocationLayer)) {\n                console.log(\"Removing layer:\", layer);\n                map.removeLayer(layer);\n            }\n        });\n        console.log(\"\\uD83D\\uDDD1️ Cleared existing data layers\");\n        let segmentsAdded = 0;\n        let segmentsWithGeometry = 0;\n        let segmentsWithoutGeometry = 0;\n        let openSegmentCount = 0;\n        let closedSegmentCount = 0;\n        console.log(\"\\uD83D\\uDEE3️ Starting to process segments:\", segmentsData.segments.length);\n        segmentsData.segments.forEach((segment, index)=>{\n            if (index < 10) {\n                console.log(\"Processing segment:\", segment.lane_id, \"Direction:\", segment.direction, \"Is closed:\", segment.is_closed);\n                if (typeof segment.geometry === \"string\") {\n                    try {\n                        var _geoJson_coordinates;\n                        const geoJson = JSON.parse(segment.geometry);\n                        console.log(\"Coordinates sample:\", (_geoJson_coordinates = geoJson.coordinates) === null || _geoJson_coordinates === void 0 ? void 0 : _geoJson_coordinates.slice(0, 2));\n                    } catch (e) {\n                        console.log(\"Failed to parse geometry:\", segment.geometry);\n                    }\n                }\n            }\n            let coordinates = null;\n            if (typeof segment.geometry === \"string\") {\n                try {\n                    const geoJson = JSON.parse(segment.geometry);\n                    coordinates = geoJson.coordinates;\n                    segmentsWithGeometry++;\n                } catch (e) {\n                    console.error(\"Failed to parse geometry for segment:\", segment.lane_id, e);\n                    segmentsWithoutGeometry++;\n                }\n            } else if (segment.geometry && segment.geometry.coordinates) {\n                coordinates = segment.geometry.coordinates;\n                segmentsWithGeometry++;\n            } else {\n                segmentsWithoutGeometry++;\n            }\n            if (coordinates && Array.isArray(coordinates)) {\n                var _segment_length_m, _segment_start_latitude, _segment_start_longitude, _segment_end_latitude, _segment_end_longitude;\n                let color, weight, opacity;\n                if (segment.is_closed) {\n                    color = \"#e74c3c\"; // Red for closed\n                    weight = 3;\n                    opacity = 0.8;\n                    closedSegmentCount++;\n                } else {\n                    color = \"#27ae60\"; // Green for open\n                    weight = 4;\n                    opacity = 0.8;\n                    openSegmentCount++;\n                }\n                let leafletCoords = coordinates;\n                if (coordinates.length > 0 && Array.isArray(coordinates[0])) {\n                    if (coordinates[0].length === 2 && coordinates[0][0] > coordinates[0][1]) {\n                        leafletCoords = coordinates.map((coord)=>[\n                                coord[1],\n                                coord[0]\n                            ]);\n                    }\n                }\n                const polyline = L.polyline(leafletCoords, {\n                    color: color,\n                    weight: weight,\n                    opacity: opacity,\n                    fillOpacity: 0.8,\n                    isDataLayer: true\n                }).addTo(map);\n                const popup = '\\n          <div style=\"font-family: \\'Segoe UI\\', sans-serif; font-size: 13px; line-height: 1.5; min-width: 200px; padding: 8px; \\n                      background-color: rgba(60, 60, 60, 0.9); color: white; border-radius: 6px; \\n                      box-shadow: 0 4px 12px rgba(0,0,0,0.3);\">\\n            <div style=\"font-weight: 700; color: white; margin-bottom: 10px; font-size: 14px; border-bottom: 2px solid '.concat(color, '; padding-bottom: 6px;\">\\n              ').concat(segment.lane_id, '\\n            </div>\\n            <div style=\"margin-bottom: 6px;\">\\n              <span style=\"color: #ecf0f1; font-weight: 500;\">Road ID:</span>\\n              <span style=\"color: white; font-weight: 600; margin-left: 8px;\">').concat(segment.road_id, '</span>\\n            </div>\\n            <div style=\"margin-bottom: 6px;\">\\n              <span style=\"color: #ecf0f1; font-weight: 500;\">Length:</span>\\n              <span style=\"color: white; font-weight: 600; margin-left: 8px;\">').concat(((_segment_length_m = segment.length_m) === null || _segment_length_m === void 0 ? void 0 : _segment_length_m.toFixed(1)) || \"N/A\", 'm</span>\\n            </div>\\n            <div style=\"margin-bottom: 6px;\">\\n              <span style=\"color: #ecf0f1; font-weight: 500;\">Status:</span>\\n              <span style=\"color: ').concat(segment.is_closed ? \"#ff6b6b\" : \"#51cf66\", '; font-weight: 600; margin-left: 8px;\">').concat(segment.is_closed ? \"Closed\" : \"Open\", '</span>\\n            </div>\\n            <div style=\"color: #bdc3c7; font-size: 11px; margin-top: 8px; padding-top: 6px; border-top: 1px solid #7f8c8d; font-style: italic;\">\\n              ').concat((_segment_start_latitude = segment.start_latitude) === null || _segment_start_latitude === void 0 ? void 0 : _segment_start_latitude.toFixed(6), \", \").concat((_segment_start_longitude = segment.start_longitude) === null || _segment_start_longitude === void 0 ? void 0 : _segment_start_longitude.toFixed(6), \" → \").concat((_segment_end_latitude = segment.end_latitude) === null || _segment_end_latitude === void 0 ? void 0 : _segment_end_latitude.toFixed(6), \", \").concat((_segment_end_longitude = segment.end_longitude) === null || _segment_end_longitude === void 0 ? void 0 : _segment_end_longitude.toFixed(6), \"\\n            </div>\\n          </div>\\n        \");\n                polyline.bindPopup(popup);\n                segmentsAdded++;\n            }\n        });\n        console.log(\"\\uD83D\\uDEE3️ Added \".concat(segmentsAdded, \" road segments to map\"));\n        console.log(\"\\uD83D\\uDCCA Segment processing summary: \".concat(segmentsWithGeometry, \" with geometry, \").concat(segmentsWithoutGeometry, \" without geometry\"));\n        let locationsAdded = 0;\n        // Generate random colors for location types\n        const generateLocationTypeColors = (locationTypes)=>{\n            const colorPalette = [\n                \"#BB8FCE\",\n                \"#45B7D1\",\n                \"#2E86AB\",\n                \"#98D8C8\",\n                \"#F7DC6F\",\n                \"#F8C471\",\n                \"#D4AC0D\",\n                \"#17A2B8\",\n                \"#E74C3C\",\n                \"#E67E22\",\n                \"#8E44AD\",\n                \"#16A085\",\n                \"#F39C12\",\n                \"#D35400\",\n                \"#2980B9\",\n                \"#C0392B\",\n                \"#3498DB\",\n                \"#9B59B6\",\n                \"#1ABC9C\",\n                \"#95A5A6\",\n                \"#E91E63\",\n                \"#9C27B0\",\n                \"#673AB7\",\n                \"#3F51B5\",\n                \"#2196F3\",\n                \"#00BCD4\",\n                \"#009688\",\n                \"#4CAF50\",\n                \"#8BC34A\",\n                \"#CDDC39\",\n                \"#FFEB3B\",\n                \"#FFC107\",\n                \"#FF9800\",\n                \"#FF5722\",\n                \"#795548\",\n                \"#607D8B\"\n            ];\n            const colors = {};\n            const usedColors = new Set();\n            locationTypes.forEach((type, index)=>{\n                // Try to assign a color that hasn't been used yet\n                let colorIndex = index % colorPalette.length;\n                let attempts = 0;\n                while(usedColors.has(colorPalette[colorIndex]) && attempts < colorPalette.length){\n                    colorIndex = (colorIndex + 1) % colorPalette.length;\n                    attempts++;\n                }\n                colors[type] = colorPalette[colorIndex];\n                usedColors.add(colorPalette[colorIndex]);\n            });\n            return colors;\n        };\n        // Get unique location types and generate colors\n        const uniqueLocationTypes = [\n            ...new Set(locationsData.locations.map((loc)=>loc.unit_type).filter(Boolean))\n        ];\n        const locationTypeColors = generateLocationTypeColors(uniqueLocationTypes);\n        console.log(\"\\uD83D\\uDCCD Processing locations...\");\n        locationsData.locations.forEach((location, index)=>{\n            if (index < 5) {\n                console.log(\"Location:\", location.location_name, \"Coords:\", location.latitude, location.longitude, \"Type:\", location.unit_type);\n            }\n            if (location.latitude && location.longitude) {\n                const markerColor = locationTypeColors[location.unit_type] || \"#95a5a6\";\n                const marker = L.circleMarker([\n                    location.latitude,\n                    location.longitude\n                ], {\n                    radius: 4,\n                    fillColor: markerColor,\n                    color: \"#fff\",\n                    weight: 1,\n                    opacity: 1,\n                    fillOpacity: 0.8,\n                    isLocationLayer: true\n                }).addTo(map);\n                const popup = '\\n          <div style=\"font-family: \\'Segoe UI\\', sans-serif; font-size: 13px; line-height: 1.5; min-width: 200px; padding: 8px; \\n                      background-color: rgba(60, 60, 60, 0.9); color: white; border-radius: 6px; \\n                      box-shadow: 0 4px 12px rgba(0,0,0,0.3);\">\\n            <div style=\"font-weight: 700; color: white; margin-bottom: 10px; font-size: 14px; border-bottom: 2px solid '.concat(markerColor, '; padding-bottom: 6px;\">\\n              ').concat(location.location_name, '\\n            </div>\\n            <div style=\"margin-bottom: 6px;\">\\n              <span style=\"color: #ecf0f1; font-weight: 500;\">Type:</span>\\n              <span style=\"color: white; font-weight: 600; margin-left: 8px;\">').concat(location.unit_type || \"Unknown\", '</span>\\n            </div>\\n            <div style=\"margin-bottom: 6px;\">\\n              <span style=\"color: #ecf0f1; font-weight: 500;\">Category:</span>\\n              <span style=\"color: white; font-weight: 600; margin-left: 8px;\">').concat(location.location_category, \"</span>\\n            </div>\\n            \").concat(location.elevation_m ? '\\n            <div style=\"margin-bottom: 6px;\">\\n              <span style=\"color: #ecf0f1; font-weight: 500;\">Elevation:</span>\\n              <span style=\"color: white; font-weight: 600; margin-left: 8px;\">'.concat(location.elevation_m.toFixed(1), \"m</span>\\n            </div>\") : \"\", \"\\n            \").concat(location.pit_name ? '\\n            <div style=\"margin-bottom: 6px;\">\\n              <span style=\"color: #ecf0f1; font-weight: 500;\">Pit:</span>\\n              <span style=\"color: white; font-weight: 600; margin-left: 8px;\">'.concat(location.pit_name, \"</span>\\n            </div>\") : \"\", \"\\n            \").concat(location.region_name ? '\\n            <div style=\"margin-bottom: 6px;\">\\n              <span style=\"color: #ecf0f1; font-weight: 500;\">Region:</span>\\n              <span style=\"color: white; font-weight: 600; margin-left: 8px;\">'.concat(location.region_name, \"</span>\\n            </div>\") : \"\", '\\n            <div style=\"color: #bdc3c7; font-size: 11px; margin-top: 8px; padding-top: 6px; border-top: 1px solid #7f8c8d; font-style: italic;\">\\n              ').concat(location.latitude.toFixed(6), \", \").concat(location.longitude.toFixed(6), \"\\n            </div>\\n          </div>\\n        \");\n                marker.bindPopup(popup);\n                locationsAdded++;\n            }\n        });\n        console.log(\"\\uD83D\\uDCCD Added \".concat(locationsAdded, \" location markers to map\"));\n        if (locationsAdded > 0 || segmentsAdded > 0) {\n            const allLatLngs = [];\n            locationsData.locations.forEach((location)=>{\n                if (location.latitude && location.longitude) {\n                    allLatLngs.push([\n                        location.latitude,\n                        location.longitude\n                    ]);\n                }\n            });\n            segmentsData.segments.forEach((segment)=>{\n                if (segment.geometry) {\n                    try {\n                        const geoJson = JSON.parse(segment.geometry);\n                        if (geoJson.coordinates && Array.isArray(geoJson.coordinates)) {\n                            geoJson.coordinates.forEach((coord)=>{\n                                allLatLngs.push([\n                                    coord[1],\n                                    coord[0]\n                                ]);\n                            });\n                        }\n                    } catch (e) {\n                    // Skip invalid geometry\n                    }\n                }\n            });\n            if (allLatLngs.length > 0) {\n                const bounds = L.latLngBounds(allLatLngs);\n                map.fitBounds(bounds, {\n                    padding: [\n                        50,\n                        50\n                    ],\n                    maxZoom: 16\n                });\n                const center = bounds.getCenter();\n                const zoom = map.getZoom();\n                console.log(\"\\uD83D\\uDDFA️ Map centered at: \".concat(center.lat.toFixed(6), \", \").concat(center.lng.toFixed(6), \" with zoom: \").concat(zoom));\n                console.log(\"\\uD83D\\uDCCA Fitted bounds to \".concat(allLatLngs.length, \" data points\"));\n            }\n        }\n        console.log(\"\\uD83C\\uDFA8 Creating legend...\");\n        addSimpleLegend(locationsData.locations.length, segmentsAdded);\n        console.log(\"\\uD83C\\uDFA8 Legend creation completed\");\n    }, [\n        locationsData,\n        segmentsData,\n        loading,\n        error\n    ]);\n    const addSimpleLegend = (locationCount, segmentCount)=>{\n        console.log(\"\\uD83C\\uDFA8 addSimpleLegend called with:\", {\n            locationCount,\n            segmentCount\n        });\n        const existingLegend = document.getElementById(\"simple-legend\");\n        if (existingLegend) {\n            console.log(\"\\uD83C\\uDFA8 Removing existing legend\");\n            existingLegend.remove();\n        }\n        let openRoads = 0;\n        let closedRoads = 0;\n        if (segmentsData === null || segmentsData === void 0 ? void 0 : segmentsData.segments) {\n            segmentsData.segments.forEach((segment)=>{\n                if (segment.is_closed) {\n                    closedRoads++;\n                } else {\n                    openRoads++;\n                }\n            });\n        }\n        const locationTypes = {};\n        if (locationsData === null || locationsData === void 0 ? void 0 : locationsData.locations) {\n            locationsData.locations.forEach((location)=>{\n                const type = location.unit_type || \"Unknown\";\n                locationTypes[type] = (locationTypes[type] || 0) + 1;\n            });\n        }\n        // Generate colors for legend using the same function\n        const generateLegendColors = (locationTypes)=>{\n            const colorPalette = [\n                \"#BB8FCE\",\n                \"#45B7D1\",\n                \"#2E86AB\",\n                \"#98D8C8\",\n                \"#F7DC6F\",\n                \"#F8C471\",\n                \"#D4AC0D\",\n                \"#17A2B8\",\n                \"#E74C3C\",\n                \"#E67E22\",\n                \"#8E44AD\",\n                \"#16A085\",\n                \"#F39C12\",\n                \"#D35400\",\n                \"#2980B9\",\n                \"#C0392B\",\n                \"#3498DB\",\n                \"#9B59B6\",\n                \"#1ABC9C\",\n                \"#95A5A6\",\n                \"#E91E63\",\n                \"#9C27B0\",\n                \"#673AB7\",\n                \"#3F51B5\",\n                \"#2196F3\",\n                \"#00BCD4\",\n                \"#009688\",\n                \"#4CAF50\",\n                \"#8BC34A\",\n                \"#CDDC39\",\n                \"#FFEB3B\",\n                \"#FFC107\",\n                \"#FF9800\",\n                \"#FF5722\",\n                \"#795548\",\n                \"#607D8B\"\n            ];\n            const colors = {};\n            const usedColors = new Set();\n            locationTypes.forEach((type, index)=>{\n                let colorIndex = index % colorPalette.length;\n                let attempts = 0;\n                while(usedColors.has(colorPalette[colorIndex]) && attempts < colorPalette.length){\n                    colorIndex = (colorIndex + 1) % colorPalette.length;\n                    attempts++;\n                }\n                colors[type] = colorPalette[colorIndex];\n                usedColors.add(colorPalette[colorIndex]);\n            });\n            return colors;\n        };\n        const locationTypeColors = generateLegendColors(Object.keys(locationTypes));\n        const legendHtml = '\\n      <div id=\"simple-legend\" style=\"position: fixed; top: 20px; right: 20px; \\n              background-color: rgba(60, 60, 60, 0.7); color: white; \\n              border-radius: 8px; font-family: \\'Segoe UI\\', sans-serif;\\n              box-shadow: 0 4px 20px rgba(0,0,0,0.6); z-index: 1000; \\n              min-width: 280px; max-height: 400px; overflow-y: auto;\\n              backdrop-filter: blur(10px); cursor: move;\">\\n        \\n        <div id=\"legend-header\" style=\"background-color: rgba(40, 40, 40, 0.9); padding: 12px 16px; \\n                    border-radius: 8px 8px 0 0; display: flex; align-items: center; justify-content: space-between; cursor: move;\"\\n             onclick=\"toggleLegend()\">\\n          <div style=\"display: flex; align-items: center;\">\\n            <div style=\"width: 20px; height: 20px; background-color: #3498db; border-radius: 4px; \\n                        margin-right: 10px; display: flex; align-items: center; justify-content: center;\">\\n              <span style=\"color: white; font-size: 12px; font-weight: bold;\">⛏</span>\\n            </div>\\n            <span style=\"color: white; font-weight: 600; font-size: 14px;\">Mine Map</span>\\n          </div>\\n          <div id=\"legend-toggle-arrow\" style=\"color: white; font-size: 16px; cursor: pointer;\">▼</div>\\n        </div>\\n        \\n        <div id=\"legend-content\" style=\"padding: 0; color: white; font-size: 12px;\">\\n          \\n          <div style=\"border-left: 3px solid #3498db; margin: 8px 0;\">\\n            <div id=\"road-layers-header\" style=\"background-color: rgba(52, 152, 219, 0.1); padding: 8px 12px; cursor: pointer; \\n                        display: flex; align-items: center; justify-content: space-between;\"\\n                 onclick=\"toggleSection(\\'road-layers-content\\', \\'road-layers-arrow\\')\">\\n              <div style=\"display: flex; align-items: center;\">\\n                <div style=\"width: 16px; height: 16px; background-color: #3498db; border-radius: 3px; \\n                            margin-right: 8px; display: flex; align-items: center; justify-content: center;\">\\n                  <span style=\"color: white; font-size: 10px;\">\\uD83D\\uDEE3</span>\\n                </div>\\n                <span style=\"color: #3498db; font-weight: 600; font-size: 13px;\">Road Layers</span>\\n                <div style=\"background-color: #3498db; color: white; border-radius: 10px; \\n                            padding: 2px 8px; margin-left: 8px; font-size: 10px;\">2</div>\\n              </div>\\n              <div id=\"road-layers-arrow\" style=\"color: #3498db; font-size: 14px;\">▼</div>\\n            </div>\\n            <div id=\"road-layers-content\" style=\"padding: 8px 12px 8px 32px;\">\\n              <div style=\"display: flex; align-items: center; margin-bottom: 6px;\">\\n                <div style=\"width: 12px; height: 3px; background-color: #27ae60; margin-right: 10px; border-radius: 2px;\"></div>\\n                <span style=\"color: #bdc3c7;\">Open Roads ('.concat(openRoads, ')</span>\\n              </div>\\n              <div style=\"display: flex; align-items: center; margin-bottom: 6px;\">\\n                <div style=\"width: 12px; height: 3px; background-color: #e74c3c; margin-right: 10px; border-radius: 2px;\"></div>\\n                <span style=\"color: #bdc3c7;\">Closed Roads (').concat(closedRoads, ')</span>\\n              </div>\\n            </div>\\n          </div>\\n          \\n          <div style=\"border-left: 3px solid #e74c3c; margin: 8px 0;\">\\n            <div id=\"location-types-header\" style=\"background-color: rgba(231, 76, 60, 0.1); padding: 8px 12px; cursor: pointer; \\n                        display: flex; align-items: center; justify-content: space-between;\"\\n                 onclick=\"toggleSection(\\'location-types-content\\', \\'location-types-arrow\\')\">\\n              <div style=\"display: flex; align-items: center;\">\\n                <div style=\"width: 16px; height: 16px; background-color: #e74c3c; border-radius: 3px; \\n                            margin-right: 8px; display: flex; align-items: center; justify-content: center;\">\\n                  <span style=\"color: white; font-size: 10px;\">\\uD83D\\uDCCD</span>\\n                </div>\\n                <span style=\"color: #e74c3c; font-weight: 600; font-size: 13px;\">Location Types</span>\\n                <div style=\"background-color: #e74c3c; color: white; border-radius: 10px; \\n                            padding: 2px 8px; margin-left: 8px; font-size: 10px;\">').concat(Object.keys(locationTypes).length, '</div>\\n              </div>\\n              <div id=\"location-types-arrow\" style=\"color: #e74c3c; font-size: 14px;\">▼</div>\\n            </div>\\n            <div id=\"location-types-content\" style=\"padding: 8px 12px 8px 32px;\">\\n              ').concat(Object.entries(locationTypes).sort((a, b)=>b[1] - a[1]).map((param)=>{\n            let [type, count] = param;\n            const color = locationTypeColors[type] || \"#95a5a6\";\n            return '\\n                <div style=\"display: flex; align-items: center; margin-bottom: 6px;\">\\n                  <div style=\"width: 8px; height: 8px; background-color: '.concat(color, '; margin-right: 10px; border-radius: 50%;\"></div>\\n                  <span style=\"color: #bdc3c7;\">').concat(type, \" (\").concat(count, \")</span>\\n                </div>\");\n        }).join(\"\"), \"\\n            </div>\\n          </div>\\n          \\n        </div>\\n      </div>\\n    \");\n        const legendElement = document.createElement(\"div\");\n        legendElement.innerHTML = legendHtml;\n        document.body.appendChild(legendElement);\n        window.toggleSection = function(contentId, arrowId) {\n            const content = document.getElementById(contentId);\n            const arrow = document.getElementById(arrowId);\n            if (content.style.display === \"none\") {\n                content.style.display = \"block\";\n                arrow.textContent = \"▼\";\n            } else {\n                content.style.display = \"none\";\n                arrow.textContent = \"▶\";\n            }\n        };\n        window.toggleLegend = function() {\n            const content = document.getElementById(\"legend-content\");\n            const arrow = document.getElementById(\"legend-toggle-arrow\");\n            if (content.style.display === \"none\") {\n                content.style.display = \"block\";\n                arrow.textContent = \"▼\";\n            } else {\n                content.style.display = \"none\";\n                arrow.textContent = \"▶\";\n            }\n        };\n        let isDragging = false;\n        let currentX;\n        let currentY;\n        let initialX;\n        let initialY;\n        let xOffset = 0;\n        let yOffset = 0;\n        const legend = document.getElementById(\"simple-legend\");\n        const header = document.getElementById(\"legend-header\");\n        header.addEventListener(\"mousedown\", dragStart);\n        document.addEventListener(\"mousemove\", drag);\n        document.addEventListener(\"mouseup\", dragEnd);\n        function dragStart(e) {\n            if (e.target.id === \"legend-toggle-arrow\") return;\n            initialX = e.clientX - xOffset;\n            initialY = e.clientY - yOffset;\n            if (e.target === header || header.contains(e.target)) {\n                isDragging = true;\n            }\n        }\n        function drag(e) {\n            if (isDragging) {\n                e.preventDefault();\n                currentX = e.clientX - initialX;\n                currentY = e.clientY - initialY;\n                xOffset = currentX;\n                yOffset = currentY;\n                legend.style.transform = \"translate3d(\".concat(currentX, \"px, \").concat(currentY, \"px, 0)\");\n            }\n        }\n        function dragEnd(e) {\n            initialX = currentX;\n            initialY = currentY;\n            isDragging = false;\n        }\n        console.log(\"\\uD83C\\uDFA8 Legend element added to DOM with collapsible functionality\");\n    };\n    if (error) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(\"div\", {\n            style: {\n                position: \"absolute\",\n                top: \"50%\",\n                left: \"50%\",\n                transform: \"translate(-50%, -50%)\",\n                zIndex: 1000,\n                background: \"rgba(255, 255, 255, 0.9)\",\n                padding: \"20px\",\n                borderRadius: \"8px\",\n                boxShadow: \"0 4px 20px rgba(0,0,0,0.3)\",\n                color: \"red\"\n            },\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(\"h3\", {\n                    children: \"Error Loading Map Data\"\n                }, void 0, false, {\n                    fileName: \"/app/components/MapComponent.js\",\n                    lineNumber: 1007,\n                    columnNumber: 9\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(\"p\", {\n                    children: [\n                        \"Error: \",\n                        error\n                    ]\n                }, void 0, true, {\n                    fileName: \"/app/components/MapComponent.js\",\n                    lineNumber: 1008,\n                    columnNumber: 9\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"/app/components/MapComponent.js\",\n            lineNumber: 995,\n            columnNumber: 7\n        }, this);\n    }\n    console.log(\"Render check:\", {\n        locationsData: (locationsData === null || locationsData === void 0 ? void 0 : (_locationsData_locations = locationsData.locations) === null || _locationsData_locations === void 0 ? void 0 : _locationsData_locations.length) || 0,\n        segmentsData: (segmentsData === null || segmentsData === void 0 ? void 0 : (_segmentsData_segments = segmentsData.segments) === null || _segmentsData_segments === void 0 ? void 0 : _segmentsData_segments.length) || 0,\n        loading,\n        error: !!error\n    });\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(\"div\", {\n        style: {\n            position: \"relative\",\n            width: \"100%\",\n            height: \"100vh\"\n        },\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(\"div\", {\n                className: \"folium-map\",\n                id: \"map\",\n                ref: mapRef,\n                style: {\n                    width: \"100%\",\n                    height: \"100vh\",\n                    minHeight: \"600px\",\n                    position: \"absolute\",\n                    top: 0,\n                    left: 0,\n                    zIndex: 1\n                }\n            }, void 0, false, {\n                fileName: \"/app/components/MapComponent.js\",\n                lineNumber: 1022,\n                columnNumber: 7\n            }, this),\n            loading && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(\"div\", {\n                style: {\n                    position: \"absolute\",\n                    top: \"50%\",\n                    left: \"50%\",\n                    transform: \"translate(-50%, -50%)\",\n                    zIndex: 1000,\n                    background: \"rgba(255, 255, 255, 0.9)\",\n                    padding: \"20px\",\n                    borderRadius: \"8px\",\n                    boxShadow: \"0 4px 20px rgba(0,0,0,0.3)\"\n                },\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(\"h3\", {\n                        children: \"Loading Dispatch Database Map...\"\n                    }, void 0, false, {\n                        fileName: \"/app/components/MapComponent.js\",\n                        lineNumber: 1048,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(\"p\", {\n                        children: \"Fetching roads and locations...\"\n                    }, void 0, false, {\n                        fileName: \"/app/components/MapComponent.js\",\n                        lineNumber: 1049,\n                        columnNumber: 11\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/app/components/MapComponent.js\",\n                lineNumber: 1037,\n                columnNumber: 9\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/app/components/MapComponent.js\",\n        lineNumber: 1021,\n        columnNumber: 5\n    }, this);\n}\n_s(MapComponent, \"vFi6ajrled7KrEGQZebJdB/Ow04=\", false, function() {\n    return [\n        _apollo_client__WEBPACK_IMPORTED_MODULE_3__.useQuery,\n        _apollo_client__WEBPACK_IMPORTED_MODULE_3__.useQuery\n    ];\n});\n_c = MapComponent;\nvar _c;\n$RefreshReg$(_c, \"MapComponent\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL01hcENvbXBvbmVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW9EO0FBQ1Y7QUFDTDtBQUVyQyxrQkFBa0I7QUFDbEIsTUFBTUssZ0JBQWdCRCxtREFBR0E7QUFnQnpCLE1BQU1FLGVBQWVGLG1EQUFHQTtBQW1CVCxTQUFTRztRQTY4QkxDLDBCQUNEQzs7SUE3OEJoQixNQUFNQyxTQUFTVCw2Q0FBTUEsQ0FBQztJQUN0QixNQUFNVSxpQkFBaUJWLDZDQUFNQSxDQUFDO0lBQzlCLE1BQU1XLG9CQUFvQlgsNkNBQU1BLENBQUM7SUFFakMsTUFBTSxFQUFFWSxNQUFNTCxhQUFhLEVBQUVNLFNBQVNDLGdCQUFnQixFQUFFQyxPQUFPQyxjQUFjLEVBQUUsR0FBR2Qsd0RBQVFBLENBQUNFLGVBQWU7UUFDeEdhLGFBQWE7UUFDYkMsYUFBYTtJQUNmO0lBRUEsTUFBTSxFQUFFTixNQUFNSixZQUFZLEVBQUVLLFNBQVNNLGVBQWUsRUFBRUosT0FBT0ssYUFBYSxFQUFFLEdBQUdsQix3REFBUUEsQ0FBQ0csY0FBYztRQUNwR2dCLFdBQVc7WUFBRUMsT0FBTztRQUFPO1FBQzNCTCxhQUFhO1FBQ2JDLGFBQWE7SUFDZjtJQUVBLE1BQU1MLFVBQVVDLG9CQUFvQks7SUFDcEMsTUFBTUosUUFBUUMsa0JBQWtCSTtJQUVoQyxNQUFNRyxzQkFBc0I7UUFDMUJaLGtCQUFrQmEsT0FBTyxHQUFHO1FBQzVCLElBQUlkLGVBQWVjLE9BQU8sRUFBRTtZQUMxQmQsZUFBZWMsT0FBTyxDQUFDQyxNQUFNO1lBQzdCZixlQUFlYyxPQUFPLEdBQUc7UUFDM0I7SUFDRjtJQUVBekIsZ0RBQVNBLENBQUM7UUFDUndCO0lBQ0YsR0FBRyxFQUFFO0lBRUx4QixnREFBU0EsQ0FBQztRQUNSLElBQUksS0FBa0IsRUFBYSxFQUFPO1FBRTFDWSxrQkFBa0JhLE9BQU8sR0FBRztRQUU1QixNQUFNRSxVQUFVO1lBQ2QsTUFBTUMsSUFBSSxDQUFDLE1BQU0sd01BQWdCLEVBQUdDLE9BQU87WUFFM0MsSUFBSUMsZUFBZTtZQUNuQixJQUFJQyxVQUFVO1lBQ2QsTUFBTUMsYUFBYTtZQUVuQixNQUFPLENBQUNGLGdCQUFnQkMsVUFBVUMsV0FBWTtnQkFDNUMsTUFBTSxJQUFJQyxRQUFRQyxDQUFBQSxVQUFXQyxXQUFXRCxTQUFTO2dCQUNqREosZUFBZU0sU0FBU0MsY0FBYyxDQUFDO2dCQUN2QyxJQUFJLENBQUNQLGNBQWM7b0JBQ2pCUSxRQUFRQyxHQUFHLENBQUMseUNBQXdEUCxPQUFmRCxVQUFVLEdBQUUsS0FBYyxPQUFYQyxZQUFXO29CQUMvRUQ7Z0JBQ0Y7WUFDRjtZQUVBLElBQUksQ0FBQ0QsY0FBYztnQkFDakJRLFFBQVF0QixLQUFLLENBQUM7Z0JBQ2Q7WUFDRjtZQUVBc0IsUUFBUUMsR0FBRyxDQUFDO1lBRVosSUFBSTVCLGVBQWVjLE9BQU8sRUFBRTtnQkFDMUJhLFFBQVFDLEdBQUcsQ0FBQztnQkFDWjVCLGVBQWVjLE9BQU8sQ0FBQ0MsTUFBTTtnQkFDN0JmLGVBQWVjLE9BQU8sR0FBRztZQUMzQjtZQUVBLElBQUlLLGdCQUFnQkEsYUFBYVUsV0FBVyxFQUFFO2dCQUM1Q0YsUUFBUUMsR0FBRyxDQUFDO2dCQUNaLE9BQU9ULGFBQWFVLFdBQVc7WUFDakM7WUFFQSxNQUFNQyxNQUFNYixFQUFFYSxHQUFHLENBQUMsT0FBTztnQkFDdkJDLFFBQVE7b0JBQUMsQ0FBQztvQkFBTTtpQkFBTTtnQkFDdEJDLEtBQUtmLEVBQUVnQixHQUFHLENBQUNDLFFBQVE7Z0JBQ25CQyxNQUFNO2dCQUNOQyxhQUFhO2dCQUNiQyxjQUFjO1lBQ2hCO1lBQ0FyQyxlQUFlYyxPQUFPLEdBQUdnQjtZQUN6QjdCLGtCQUFrQmEsT0FBTyxHQUFHO1lBQzVCYSxRQUFRQyxHQUFHLENBQUM7WUFFWlUsT0FBT1IsR0FBRyxHQUFHQTtZQUNiUSxPQUFPQyxRQUFRLEdBQUdUO1lBRWxCLE1BQU1VLDhDQUE4Q3ZCLEVBQUV3QixTQUFTLENBQzdELDhMQUNBO2dCQUNFQyxTQUFTO2dCQUNUQyxTQUFTO2dCQUNUQyxlQUFlO2dCQUNmQyxRQUFRO2dCQUNSQyxhQUFhO2dCQUNiQyxZQUFZO2dCQUNaQyxjQUFjO2dCQUNkQyxLQUFLO2dCQUNMQyxTQUFTO1lBQ1g7WUFFRlYsNENBQTRDVyxLQUFLLENBQUNyQjtZQUVsRCxNQUFNc0IsOENBQThDbkMsRUFBRXdCLFNBQVMsQ0FDN0QscUxBQ0E7Z0JBQ0VDLFNBQVM7Z0JBQ1RDLFNBQVM7Z0JBQ1RDLGVBQWU7Z0JBQ2ZDLFFBQVE7Z0JBQ1JDLGFBQWE7Z0JBQ2JDLFlBQVk7Z0JBQ1pDLGNBQWM7Z0JBQ2RDLEtBQUs7Z0JBQ0xDLFNBQVM7WUFDWDtZQUdGLE1BQU1HLDhDQUE4Q3BDLEVBQUV3QixTQUFTLENBQzdELG9MQUNBO2dCQUNFQyxTQUFTO2dCQUNUQyxTQUFTO2dCQUNUQyxlQUFlO2dCQUNmQyxRQUFRO2dCQUNSQyxhQUFhO2dCQUNiQyxZQUFZO2dCQUNaQyxjQUFjO2dCQUNkQyxLQUFLO2dCQUNMQyxTQUFTO1lBQ1g7WUFHRixNQUFNSSw4Q0FBOENyQyxFQUFFd0IsU0FBUyxDQUM3RCxxTEFDQTtnQkFDRUMsU0FBUztnQkFDVEMsU0FBUztnQkFDVEMsZUFBZTtnQkFDZkMsUUFBUTtnQkFDUkMsYUFBYTtnQkFDYkMsWUFBWTtnQkFDWkMsY0FBYztnQkFDZEMsS0FBSztnQkFDTEMsU0FBUztZQUNYO1lBR0YsTUFBTUssOENBQThDdEMsRUFBRXdCLFNBQVMsQ0FDN0Qsb0xBQ0E7Z0JBQ0VDLFNBQVM7Z0JBQ1RDLFNBQVM7Z0JBQ1RDLGVBQWU7Z0JBQ2ZDLFFBQVE7Z0JBQ1JDLGFBQWE7Z0JBQ2JDLFlBQVk7Z0JBQ1pDLGNBQWM7Z0JBQ2RDLEtBQUs7Z0JBQ0xDLFNBQVM7WUFDWDtZQUdGLE1BQU1NLDhDQUE4Q3ZDLEVBQUV3QixTQUFTLENBQzdELGlMQUNBO2dCQUNFQyxTQUFTO2dCQUNUQyxTQUFTO2dCQUNUQyxlQUFlO2dCQUNmQyxRQUFRO2dCQUNSQyxhQUFhO2dCQUNiQyxZQUFZO2dCQUNaQyxjQUFjO2dCQUNkQyxLQUFLO2dCQUNMQyxTQUFTO1lBQ1g7WUFHRixNQUFNTyw4Q0FBOEN4QyxFQUFFd0IsU0FBUyxDQUM3RCw0TEFDQTtnQkFDRUMsU0FBUztnQkFDVEMsU0FBUztnQkFDVEMsZUFBZTtnQkFDZkMsUUFBUTtnQkFDUkMsYUFBYTtnQkFDYkMsWUFBWTtnQkFDWkMsY0FBYztnQkFDZEMsS0FBSztnQkFDTEMsU0FBUztZQUNYO1lBR0YsTUFBTVEsOENBQThDekMsRUFBRXdCLFNBQVMsQ0FDN0QsaUxBQ0E7Z0JBQ0VDLFNBQVM7Z0JBQ1RDLFNBQVM7Z0JBQ1RDLGVBQWU7Z0JBQ2ZDLFFBQVE7Z0JBQ1JDLGFBQWE7Z0JBQ2JDLFlBQVk7Z0JBQ1pDLGNBQWM7Z0JBQ2RDLEtBQUs7Z0JBQ0xDLFNBQVM7WUFDWDtZQUdGLE1BQU1TLGFBQWE7Z0JBQ2pCLHFCQUFxQm5CO2dCQUNyQixlQUFlWTtnQkFDZixXQUFXQztnQkFDWCxhQUFhQztnQkFDYixZQUFZQztnQkFDWixRQUFRQztnQkFDUixvQkFBb0JDO2dCQUNwQixnQkFBZ0JDO1lBQ2xCO1lBRUEsTUFBTUUsZUFBZTNDLEVBQUU0QyxPQUFPLENBQUNDLE1BQU0sQ0FBQ0gsWUFBWSxDQUFDLEdBQUc7Z0JBQ3BESSxVQUFVO2dCQUNWQyxXQUFXO1lBQ2IsR0FBR2IsS0FBSyxDQUFDckI7WUFFVE4sV0FBVztnQkFDVCxNQUFNeUMsc0JBQXNCeEMsU0FBU3lDLGFBQWEsQ0FBQztnQkFDbkQsSUFBSUQscUJBQXFCO29CQUN2QixJQUFJRSxhQUFhO29CQUNqQixJQUFJQztvQkFDSixJQUFJQztvQkFDSixJQUFJQztvQkFDSixJQUFJQztvQkFDSixJQUFJQyxVQUFVO29CQUNkLElBQUlDLFVBQVU7b0JBRWRSLG9CQUFvQlMsZ0JBQWdCLENBQUMsYUFBYUM7b0JBQ2xEbEQsU0FBU2lELGdCQUFnQixDQUFDLGFBQWFFO29CQUN2Q25ELFNBQVNpRCxnQkFBZ0IsQ0FBQyxXQUFXRztvQkFFckMsU0FBU0YsVUFBVUcsQ0FBQzt3QkFDbEIsSUFBSUEsRUFBRUMsTUFBTSxDQUFDQyxPQUFPLENBQUMscUNBQXFDLFFBQVEsbUNBQW1DO3dCQUVyR1YsV0FBV1EsRUFBRUcsT0FBTyxHQUFHVDt3QkFDdkJELFdBQVdPLEVBQUVJLE9BQU8sR0FBR1Q7d0JBRXZCLElBQUlLLEVBQUVDLE1BQU0sS0FBS2QsdUJBQXVCQSxvQkFBb0JrQixRQUFRLENBQUNMLEVBQUVDLE1BQU0sR0FBRzs0QkFDOUVaLGFBQWE7NEJBQ2JGLG9CQUFvQm1CLEtBQUssQ0FBQ0MsTUFBTSxHQUFHO3dCQUNyQztvQkFDRjtvQkFFQSxTQUFTVCxLQUFLRSxDQUFDO3dCQUNiLElBQUlYLFlBQVk7NEJBQ2RXLEVBQUVRLGNBQWM7NEJBQ2hCbEIsV0FBV1UsRUFBRUcsT0FBTyxHQUFHWDs0QkFDdkJELFdBQVdTLEVBQUVJLE9BQU8sR0FBR1g7NEJBRXZCQyxVQUFVSjs0QkFDVkssVUFBVUo7NEJBRVZKLG9CQUFvQm1CLEtBQUssQ0FBQ0csU0FBUyxHQUFHLGVBQThCbEIsT0FBZkQsVUFBUyxRQUFlLE9BQVRDLFVBQVM7d0JBQy9FO29CQUNGO29CQUVBLFNBQVNRLFFBQVFDLENBQUM7d0JBQ2hCUixXQUFXRjt3QkFDWEcsV0FBV0Y7d0JBQ1hGLGFBQWE7d0JBQ2JGLG9CQUFvQm1CLEtBQUssQ0FBQ0MsTUFBTSxHQUFHO29CQUNyQztnQkFDRjtZQUNGLEdBQUc7WUFFSDdELFdBQVc7Z0JBQ1QsTUFBTTRELFFBQVEzRCxTQUFTK0QsYUFBYSxDQUFDO2dCQUNyQ0osTUFBTUssV0FBVyxHQUFJO2dCQTBHckJoRSxTQUFTaUUsSUFBSSxDQUFDQyxXQUFXLENBQUNQO1lBQzVCLEdBQUc7WUFFSCxJQUFJUSxrQkFBa0I7WUFDdEIsSUFBSUMsUUFBUUM7WUFFWmhFLElBQUlpRSxZQUFZLEdBQUdyQixnQkFBZ0IsQ0FBQyxlQUFlLFNBQVNJLENBQUM7Z0JBQzNEQSxFQUFFUSxjQUFjO2dCQUNoQk0sa0JBQWtCO2dCQUNsQkMsU0FBU2YsRUFBRUcsT0FBTztnQkFDbEJhLFNBQVNoQixFQUFFSSxPQUFPO2dCQUVsQnpELFNBQVN1RSxJQUFJLENBQUNaLEtBQUssQ0FBQ0MsTUFBTSxHQUFHO1lBQy9CO1lBRUF2RCxJQUFJaUUsWUFBWSxHQUFHckIsZ0JBQWdCLENBQUMsYUFBYSxTQUFTSSxDQUFDO2dCQUN6RCxJQUFJYyxpQkFBaUI7b0JBQ25CLE1BQU1LLFNBQVNuQixFQUFFRyxPQUFPLEdBQUdZO29CQUMzQixNQUFNSyxTQUFTcEIsRUFBRUksT0FBTyxHQUFHWTtvQkFFM0IsTUFBTUssZ0JBQWdCRixTQUFTO29CQUMvQixNQUFNRyxjQUFjRixTQUFTO29CQUU3QixNQUFNRyxpQkFBaUJ2RSxJQUFJd0UsVUFBVSxHQUFHeEUsSUFBSXdFLFVBQVUsS0FBSztvQkFDM0QsTUFBTUMsYUFBYSxDQUFDRixpQkFBaUJGLGFBQVksSUFBSztvQkFFdEQsSUFBSXJFLElBQUkwRSxVQUFVLEVBQUU7d0JBQ2xCMUUsSUFBSTBFLFVBQVUsQ0FBQ0Q7b0JBQ2pCO29CQUVBLElBQUl6RSxJQUFJMkUsUUFBUSxFQUFFO3dCQUNoQixNQUFNQyxlQUFlNUUsSUFBSTZFLFFBQVEsR0FBRzdFLElBQUk2RSxRQUFRLEtBQUs7d0JBQ3JELE1BQU1DLFdBQVdDLEtBQUtDLEdBQUcsQ0FBQyxHQUFHRCxLQUFLRSxHQUFHLENBQUMsSUFBSUwsZUFBZU47d0JBQ3pEdEUsSUFBSTJFLFFBQVEsQ0FBQ0c7b0JBQ2Y7b0JBRUFmLFNBQVNmLEVBQUVHLE9BQU87b0JBQ2xCYSxTQUFTaEIsRUFBRUksT0FBTztnQkFDcEI7WUFDRjtZQUVBcEQsSUFBSWlFLFlBQVksR0FBR3JCLGdCQUFnQixDQUFDLFdBQVcsU0FBU0ksQ0FBQztnQkFDdkQsSUFBSWMsaUJBQWlCO29CQUNuQkEsa0JBQWtCO29CQUNsQm5FLFNBQVN1RSxJQUFJLENBQUNaLEtBQUssQ0FBQ0MsTUFBTSxHQUFHO2dCQUMvQjtZQUNGO1lBRUF2RCxJQUFJaUUsWUFBWSxHQUFHckIsZ0JBQWdCLENBQUMsWUFBWSxTQUFTSSxDQUFDO2dCQUN4REEsRUFBRVEsY0FBYztnQkFDaEIsSUFBSXhELElBQUkwRSxVQUFVLEVBQUU7b0JBQ2xCMUUsSUFBSTBFLFVBQVUsQ0FBQztnQkFDakI7Z0JBQ0EsSUFBSTFFLElBQUkyRSxRQUFRLEVBQUU7b0JBQ2hCM0UsSUFBSTJFLFFBQVEsQ0FBQztnQkFDZjtZQUNGO1FBQ0Y7UUFFQXpGO0lBQ0YsR0FBRyxFQUFFO0lBSUwzQixnREFBU0EsQ0FBQztZQUdTUSwwQkFDREM7UUFIaEI2QixRQUFRQyxHQUFHLENBQUMsZUFBZTtZQUN6Qm9GLFVBQVUsQ0FBQyxDQUFDaEgsZUFBZWMsT0FBTztZQUNsQ2pCLGVBQWVBLENBQUFBLDBCQUFBQSxxQ0FBQUEsMkJBQUFBLGNBQWVvSCxTQUFTLGNBQXhCcEgsK0NBQUFBLHlCQUEwQnFILE1BQU0sS0FBSTtZQUNuRHBILGNBQWNBLENBQUFBLHlCQUFBQSxvQ0FBQUEseUJBQUFBLGFBQWNxSCxRQUFRLGNBQXRCckgsNkNBQUFBLHVCQUF3Qm9ILE1BQU0sS0FBSTtZQUNoRC9HO1lBQ0FFLE9BQU8sQ0FBQyxDQUFDQTtRQUNYO1FBRUEsSUFBSSxDQUFDTCxlQUFlYyxPQUFPLEVBQUU7WUFDM0JhLFFBQVFDLEdBQUcsQ0FBQztZQUNaO1FBQ0Y7UUFFQSxJQUFJekIsU0FBUztZQUNYd0IsUUFBUUMsR0FBRyxDQUFDO1lBQ1o7UUFDRjtRQUVBLElBQUl2QixPQUFPO1lBQ1RzQixRQUFRdEIsS0FBSyxDQUFDLG9CQUFvQkE7WUFDbEM7UUFDRjtRQUVBLElBQUksRUFBQ1IsMEJBQUFBLG9DQUFBQSxjQUFlb0gsU0FBUyxHQUFFO1lBQzdCdEYsUUFBUUMsR0FBRyxDQUFDO1lBQ1o7UUFDRjtRQUVBLElBQUksRUFBQzlCLHlCQUFBQSxtQ0FBQUEsYUFBY3FILFFBQVEsR0FBRTtZQUMzQnhGLFFBQVFDLEdBQUcsQ0FBQztZQUNaO1FBQ0Y7UUFFQUQsUUFBUUMsR0FBRyxDQUFDO1FBQ1pELFFBQVFDLEdBQUcsQ0FBQyxnQ0FBc0IvQixjQUFjb0gsU0FBUyxDQUFDQyxNQUFNLEVBQUU7UUFDbEV2RixRQUFRQyxHQUFHLENBQUMsZ0NBQXNCOUIsYUFBYXFILFFBQVEsQ0FBQ0QsTUFBTSxFQUFFO1FBRWhFLE1BQU1wRixNQUFNOUIsZUFBZWMsT0FBTztRQUNsQyxNQUFNRyxJQUFJcUIsT0FBT3JCLENBQUM7UUFFbEJhLElBQUlzRixTQUFTLENBQUMsQ0FBQ0M7WUFDYixJQUFJQSxNQUFNQyxPQUFPLElBQUtELENBQUFBLE1BQU1DLE9BQU8sQ0FBQ0MsV0FBVyxJQUFJRixNQUFNQyxPQUFPLENBQUNFLGVBQWUsR0FBRztnQkFDakY3RixRQUFRQyxHQUFHLENBQUMsbUJBQW1CeUY7Z0JBQy9CdkYsSUFBSTJGLFdBQVcsQ0FBQ0o7WUFDbEI7UUFDRjtRQUNBMUYsUUFBUUMsR0FBRyxDQUFDO1FBRVosSUFBSThGLGdCQUFnQjtRQUNwQixJQUFJQyx1QkFBdUI7UUFDM0IsSUFBSUMsMEJBQTBCO1FBQzlCLElBQUlDLG1CQUFtQjtRQUN2QixJQUFJQyxxQkFBcUI7UUFFekJuRyxRQUFRQyxHQUFHLENBQUMsK0NBQXFDOUIsYUFBYXFILFFBQVEsQ0FBQ0QsTUFBTTtRQUU3RXBILGFBQWFxSCxRQUFRLENBQUNZLE9BQU8sQ0FBQyxDQUFDQyxTQUFTQztZQUN0QyxJQUFJQSxRQUFRLElBQUk7Z0JBQ2R0RyxRQUFRQyxHQUFHLENBQUMsdUJBQXVCb0csUUFBUUUsT0FBTyxFQUFFLGNBQWNGLFFBQVFHLFNBQVMsRUFBRSxjQUFjSCxRQUFRSSxTQUFTO2dCQUNwSCxJQUFJLE9BQU9KLFFBQVFLLFFBQVEsS0FBSyxVQUFVO29CQUN4QyxJQUFJOzRCQUVpQ0M7d0JBRG5DLE1BQU1BLFVBQVVDLEtBQUtDLEtBQUssQ0FBQ1IsUUFBUUssUUFBUTt3QkFDM0MxRyxRQUFRQyxHQUFHLENBQUMsd0JBQXVCMEcsdUJBQUFBLFFBQVFHLFdBQVcsY0FBbkJILDJDQUFBQSxxQkFBcUJJLEtBQUssQ0FBQyxHQUFHO29CQUNuRSxFQUFFLE9BQU81RCxHQUFHO3dCQUNWbkQsUUFBUUMsR0FBRyxDQUFDLDZCQUE2Qm9HLFFBQVFLLFFBQVE7b0JBQzNEO2dCQUNGO1lBQ0Y7WUFFQSxJQUFJSSxjQUFjO1lBQ2xCLElBQUksT0FBT1QsUUFBUUssUUFBUSxLQUFLLFVBQVU7Z0JBQ3hDLElBQUk7b0JBQ0YsTUFBTUMsVUFBVUMsS0FBS0MsS0FBSyxDQUFDUixRQUFRSyxRQUFRO29CQUMzQ0ksY0FBY0gsUUFBUUcsV0FBVztvQkFDakNkO2dCQUNGLEVBQUUsT0FBTzdDLEdBQUc7b0JBQ1ZuRCxRQUFRdEIsS0FBSyxDQUFDLHlDQUF5QzJILFFBQVFFLE9BQU8sRUFBRXBEO29CQUN4RThDO2dCQUNGO1lBQ0YsT0FBTyxJQUFJSSxRQUFRSyxRQUFRLElBQUlMLFFBQVFLLFFBQVEsQ0FBQ0ksV0FBVyxFQUFFO2dCQUMzREEsY0FBY1QsUUFBUUssUUFBUSxDQUFDSSxXQUFXO2dCQUMxQ2Q7WUFDRixPQUFPO2dCQUNMQztZQUNGO1lBRUEsSUFBSWEsZUFBZUUsTUFBTUMsT0FBTyxDQUFDSCxjQUFjO29CQTBDMkJULG1CQU9oRUEseUJBQXVDQSwwQkFBeUNBLHVCQUFxQ0E7Z0JBaEQ3SCxJQUFJYSxPQUFPQyxRQUFRNUY7Z0JBQ25CLElBQUk4RSxRQUFRSSxTQUFTLEVBQUU7b0JBQ3JCUyxRQUFRLFdBQVksaUJBQWlCO29CQUNyQ0MsU0FBUztvQkFDVDVGLFVBQVU7b0JBQ1Y0RTtnQkFDRixPQUFPO29CQUNMZSxRQUFRLFdBQVksaUJBQWlCO29CQUNyQ0MsU0FBUztvQkFDVDVGLFVBQVU7b0JBQ1YyRTtnQkFDRjtnQkFFQSxJQUFJa0IsZ0JBQWdCTjtnQkFDcEIsSUFBSUEsWUFBWXZCLE1BQU0sR0FBRyxLQUFLeUIsTUFBTUMsT0FBTyxDQUFDSCxXQUFXLENBQUMsRUFBRSxHQUFHO29CQUMzRCxJQUFJQSxXQUFXLENBQUMsRUFBRSxDQUFDdkIsTUFBTSxLQUFLLEtBQUt1QixXQUFXLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBR0EsV0FBVyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7d0JBQ3hFTSxnQkFBZ0JOLFlBQVkzRyxHQUFHLENBQUNrSCxDQUFBQSxRQUFTO2dDQUFDQSxLQUFLLENBQUMsRUFBRTtnQ0FBRUEsS0FBSyxDQUFDLEVBQUU7NkJBQUM7b0JBQy9EO2dCQUNGO2dCQUVBLE1BQU1DLFdBQVdoSSxFQUFFZ0ksUUFBUSxDQUFDRixlQUFlO29CQUN6Q0YsT0FBT0E7b0JBQ1BDLFFBQVFBO29CQUNSNUYsU0FBU0E7b0JBQ1RnRyxhQUFhO29CQUNiM0IsYUFBYTtnQkFDZixHQUFHcEUsS0FBSyxDQUFDckI7Z0JBRVQsTUFBTXFILFFBQVEsa2FBS05uQixPQUR5R2EsT0FBTSw0Q0FLL0NiLE9BSmhFQSxRQUFRRSxPQUFPLEVBQUMsc09BUWdERixPQUpBQSxRQUFRb0IsT0FBTyxFQUFDLDRPQVE1RHBCLE9BSjRDQSxFQUFBQSxvQkFBQUEsUUFBUXFCLFFBQVEsY0FBaEJyQix3Q0FBQUEsa0JBQWtCc0IsT0FBTyxDQUFDLE9BQU0sT0FBTSxpTUFJQ3RCLE9BQW5GQSxRQUFRSSxTQUFTLEdBQUcsWUFBWSxXQUFVLGtEQUF5Q0osUUFBUUksU0FBUyxHQUFHLFdBQVcsUUFBTyx5TUFHN0lKLDBCQUFBQSxRQUFRdUIsY0FBYyxjQUF0QnZCLDhDQUFBQSx3QkFBd0JzQixPQUFPLENBQUMsSUFBRyxjQUFJdEIsMkJBQUFBLFFBQVF3QixlQUFlLGNBQXZCeEIsK0NBQUFBLHlCQUF5QnNCLE9BQU8sQ0FBQyxJQUFHLGVBQUt0Qix3QkFBQUEsUUFBUXlCLFlBQVksY0FBcEJ6Qiw0Q0FBQUEsc0JBQXNCc0IsT0FBTyxDQUFDLElBQUcsTUFBc0MsUUFBbEN0Qix5QkFBQUEsUUFBUTBCLGFBQWEsY0FBckIxQiw2Q0FBQUEsdUJBQXVCc0IsT0FBTyxDQUFDLElBQUc7Z0JBSS9KTCxTQUFTVSxTQUFTLENBQUNSO2dCQUNuQnpCO1lBQ0Y7UUFDRjtRQUVBL0YsUUFBUUMsR0FBRyxDQUFDLHVCQUEyQixPQUFkOEYsZUFBYztRQUN2Qy9GLFFBQVFDLEdBQUcsQ0FBQyw0Q0FBeUVnRyxPQUF2Q0Qsc0JBQXFCLG9CQUEwQyxPQUF4QkMseUJBQXdCO1FBRTdHLElBQUlnQyxpQkFBaUI7UUFDckIsNENBQTRDO1FBQzVDLE1BQU1DLDZCQUE2QixDQUFDQztZQUNsQyxNQUFNQyxlQUFlO2dCQUNuQjtnQkFBVztnQkFBVztnQkFBVztnQkFBVztnQkFBVztnQkFDdkQ7Z0JBQVc7Z0JBQVc7Z0JBQVc7Z0JBQVc7Z0JBQVc7Z0JBQ3ZEO2dCQUFXO2dCQUFXO2dCQUFXO2dCQUFXO2dCQUFXO2dCQUN2RDtnQkFBVztnQkFBVztnQkFBVztnQkFBVztnQkFBVztnQkFDdkQ7Z0JBQVc7Z0JBQVc7Z0JBQVc7Z0JBQVc7Z0JBQVc7Z0JBQ3ZEO2dCQUFXO2dCQUFXO2dCQUFXO2dCQUFXO2dCQUFXO2FBQ3hEO1lBRUQsTUFBTUMsU0FBUyxDQUFDO1lBQ2hCLE1BQU1DLGFBQWEsSUFBSUM7WUFFdkJKLGNBQWMvQixPQUFPLENBQUMsQ0FBQ29DLE1BQU1sQztnQkFDM0Isa0RBQWtEO2dCQUNsRCxJQUFJbUMsYUFBYW5DLFFBQVE4QixhQUFhN0MsTUFBTTtnQkFDNUMsSUFBSW1ELFdBQVc7Z0JBRWYsTUFBT0osV0FBV0ssR0FBRyxDQUFDUCxZQUFZLENBQUNLLFdBQVcsS0FBS0MsV0FBV04sYUFBYTdDLE1BQU0sQ0FBRTtvQkFDakZrRCxhQUFhLENBQUNBLGFBQWEsS0FBS0wsYUFBYTdDLE1BQU07b0JBQ25EbUQ7Z0JBQ0Y7Z0JBRUFMLE1BQU0sQ0FBQ0csS0FBSyxHQUFHSixZQUFZLENBQUNLLFdBQVc7Z0JBQ3ZDSCxXQUFXTSxHQUFHLENBQUNSLFlBQVksQ0FBQ0ssV0FBVztZQUN6QztZQUVBLE9BQU9KO1FBQ1Q7UUFFQSxnREFBZ0Q7UUFDaEQsTUFBTVEsc0JBQXNCO2VBQUksSUFBSU4sSUFBSXJLLGNBQWNvSCxTQUFTLENBQUNuRixHQUFHLENBQUMySSxDQUFBQSxNQUFPQSxJQUFJQyxTQUFTLEVBQUVDLE1BQU0sQ0FBQ0M7U0FBVTtRQUMzRyxNQUFNQyxxQkFBcUJoQiwyQkFBMkJXO1FBRXREN0ksUUFBUUMsR0FBRyxDQUFDO1FBQ1ovQixjQUFjb0gsU0FBUyxDQUFDYyxPQUFPLENBQUMsQ0FBQytDLFVBQVU3QztZQUN6QyxJQUFJQSxRQUFRLEdBQUc7Z0JBQ2J0RyxRQUFRQyxHQUFHLENBQUMsYUFBYWtKLFNBQVNDLGFBQWEsRUFBRSxXQUFXRCxTQUFTRSxRQUFRLEVBQUVGLFNBQVNHLFNBQVMsRUFBRSxTQUFTSCxTQUFTSixTQUFTO1lBQ2hJO1lBRUEsSUFBSUksU0FBU0UsUUFBUSxJQUFJRixTQUFTRyxTQUFTLEVBQUU7Z0JBQzNDLE1BQU1DLGNBQWNMLGtCQUFrQixDQUFDQyxTQUFTSixTQUFTLENBQUMsSUFBSTtnQkFFOUQsTUFBTVMsU0FBU2xLLEVBQUVtSyxZQUFZLENBQUM7b0JBQUNOLFNBQVNFLFFBQVE7b0JBQUVGLFNBQVNHLFNBQVM7aUJBQUMsRUFBRTtvQkFDckVJLFFBQVE7b0JBQ1JDLFdBQVdKO29CQUNYckMsT0FBTztvQkFDUEMsUUFBUTtvQkFDUjVGLFNBQVM7b0JBQ1RnRyxhQUFhO29CQUNiMUIsaUJBQWlCO2dCQUNuQixHQUFHckUsS0FBSyxDQUFDckI7Z0JBRVQsTUFBTXFILFFBQVEsa2FBS04yQixPQUR5R0ksYUFBWSw0Q0FLckRKLE9BSmhFQSxTQUFTQyxhQUFhLEVBQUMsbU9BUXlDRCxPQUpBQSxTQUFTSixTQUFTLElBQUksV0FBVSw4T0FNbEdJLE9BRmtFQSxTQUFTUyxpQkFBaUIsRUFBQyw2Q0FPN0ZULE9BTEFBLFNBQVNVLFdBQVcsR0FBRyxtTkFHMkUsT0FBaENWLFNBQVNVLFdBQVcsQ0FBQ2xDLE9BQU8sQ0FBQyxJQUFHLGtDQUMxRixJQUFHLGtCQU1Yd0IsT0FMQUEsU0FBU1csUUFBUSxHQUFHLDZNQUdnRSxPQUFsQlgsU0FBU1csUUFBUSxFQUFDLGlDQUM1RSxJQUFHLGtCQU9UWCxPQU5GQSxTQUFTWSxXQUFXLEdBQUcsZ05BR2dFLE9BQXJCWixTQUFTWSxXQUFXLEVBQUMsaUNBQy9FLElBQUcsc0tBRXdCWixPQUFqQ0EsU0FBU0UsUUFBUSxDQUFDMUIsT0FBTyxDQUFDLElBQUcsTUFBa0MsT0FBOUJ3QixTQUFTRyxTQUFTLENBQUMzQixPQUFPLENBQUMsSUFBRztnQkFJdkU2QixPQUFPeEIsU0FBUyxDQUFDUjtnQkFDakJTO1lBQ0Y7UUFDRjtRQUVBakksUUFBUUMsR0FBRyxDQUFDLHNCQUEyQixPQUFmZ0ksZ0JBQWU7UUFFdkMsSUFBSUEsaUJBQWlCLEtBQUtsQyxnQkFBZ0IsR0FBRztZQUMzQyxNQUFNaUUsYUFBYSxFQUFFO1lBRXJCOUwsY0FBY29ILFNBQVMsQ0FBQ2MsT0FBTyxDQUFDLENBQUMrQztnQkFDL0IsSUFBSUEsU0FBU0UsUUFBUSxJQUFJRixTQUFTRyxTQUFTLEVBQUU7b0JBQzNDVSxXQUFXQyxJQUFJLENBQUM7d0JBQUNkLFNBQVNFLFFBQVE7d0JBQUVGLFNBQVNHLFNBQVM7cUJBQUM7Z0JBQ3pEO1lBQ0Y7WUFFQW5MLGFBQWFxSCxRQUFRLENBQUNZLE9BQU8sQ0FBQyxDQUFDQztnQkFDN0IsSUFBSUEsUUFBUUssUUFBUSxFQUFFO29CQUNwQixJQUFJO3dCQUNGLE1BQU1DLFVBQVVDLEtBQUtDLEtBQUssQ0FBQ1IsUUFBUUssUUFBUTt3QkFDM0MsSUFBSUMsUUFBUUcsV0FBVyxJQUFJRSxNQUFNQyxPQUFPLENBQUNOLFFBQVFHLFdBQVcsR0FBRzs0QkFDN0RILFFBQVFHLFdBQVcsQ0FBQ1YsT0FBTyxDQUFDaUIsQ0FBQUE7Z0NBQzFCMkMsV0FBV0MsSUFBSSxDQUFDO29DQUFDNUMsS0FBSyxDQUFDLEVBQUU7b0NBQUVBLEtBQUssQ0FBQyxFQUFFO2lDQUFDOzRCQUN0Qzt3QkFDRjtvQkFDRixFQUFFLE9BQU9sRSxHQUFHO29CQUNWLHdCQUF3QjtvQkFDMUI7Z0JBQ0Y7WUFDRjtZQUVBLElBQUk2RyxXQUFXekUsTUFBTSxHQUFHLEdBQUc7Z0JBQ3pCLE1BQU0yRSxTQUFTNUssRUFBRTZLLFlBQVksQ0FBQ0g7Z0JBRTlCN0osSUFBSWlLLFNBQVMsQ0FBQ0YsUUFBUTtvQkFDcEJHLFNBQVM7d0JBQUM7d0JBQUk7cUJBQUc7b0JBQ2pCckosU0FBUztnQkFDWDtnQkFFQSxNQUFNWixTQUFTOEosT0FBT0ksU0FBUztnQkFDL0IsTUFBTTlKLE9BQU9MLElBQUlvSyxPQUFPO2dCQUN4QnZLLFFBQVFDLEdBQUcsQ0FBQyxrQ0FBa0RHLE9BQTFCQSxPQUFPb0ssR0FBRyxDQUFDN0MsT0FBTyxDQUFDLElBQUcsTUFBd0NuSCxPQUFwQ0osT0FBT3FLLEdBQUcsQ0FBQzlDLE9BQU8sQ0FBQyxJQUFHLGdCQUFtQixPQUFMbkg7Z0JBQ2xHUixRQUFRQyxHQUFHLENBQUMsaUNBQXlDLE9BQWxCK0osV0FBV3pFLE1BQU0sRUFBQztZQUN2RDtRQUNGO1FBRUF2RixRQUFRQyxHQUFHLENBQUM7UUFDWnlLLGdCQUFnQnhNLGNBQWNvSCxTQUFTLENBQUNDLE1BQU0sRUFBRVE7UUFDaEQvRixRQUFRQyxHQUFHLENBQUM7SUFFZCxHQUFHO1FBQUMvQjtRQUFlQztRQUFjSztRQUFTRTtLQUFNO0lBRWhELE1BQU1nTSxrQkFBa0IsQ0FBQ0MsZUFBZUM7UUFDdEM1SyxRQUFRQyxHQUFHLENBQUMsNkNBQW1DO1lBQUUwSztZQUFlQztRQUFhO1FBRTdFLE1BQU1DLGlCQUFpQi9LLFNBQVNDLGNBQWMsQ0FBQztRQUMvQyxJQUFJOEssZ0JBQWdCO1lBQ2xCN0ssUUFBUUMsR0FBRyxDQUFDO1lBQ1o0SyxlQUFlekwsTUFBTTtRQUN2QjtRQUVBLElBQUkwTCxZQUFZO1FBQ2hCLElBQUlDLGNBQWM7UUFDbEIsSUFBSTVNLHlCQUFBQSxtQ0FBQUEsYUFBY3FILFFBQVEsRUFBRTtZQUMxQnJILGFBQWFxSCxRQUFRLENBQUNZLE9BQU8sQ0FBQ0MsQ0FBQUE7Z0JBQzVCLElBQUlBLFFBQVFJLFNBQVMsRUFBRTtvQkFDckJzRTtnQkFDRixPQUFPO29CQUNMRDtnQkFDRjtZQUNGO1FBQ0Y7UUFFQSxNQUFNM0MsZ0JBQWdCLENBQUM7UUFDdkIsSUFBSWpLLDBCQUFBQSxvQ0FBQUEsY0FBZW9ILFNBQVMsRUFBRTtZQUM1QnBILGNBQWNvSCxTQUFTLENBQUNjLE9BQU8sQ0FBQytDLENBQUFBO2dCQUM5QixNQUFNWCxPQUFPVyxTQUFTSixTQUFTLElBQUk7Z0JBQ25DWixhQUFhLENBQUNLLEtBQUssR0FBRyxDQUFDTCxhQUFhLENBQUNLLEtBQUssSUFBSSxLQUFLO1lBQ3JEO1FBQ0Y7UUFFQSxxREFBcUQ7UUFDckQsTUFBTXdDLHVCQUF1QixDQUFDN0M7WUFDNUIsTUFBTUMsZUFBZTtnQkFDbkI7Z0JBQVc7Z0JBQVc7Z0JBQVc7Z0JBQVc7Z0JBQVc7Z0JBQ3ZEO2dCQUFXO2dCQUFXO2dCQUFXO2dCQUFXO2dCQUFXO2dCQUN2RDtnQkFBVztnQkFBVztnQkFBVztnQkFBVztnQkFBVztnQkFDdkQ7Z0JBQVc7Z0JBQVc7Z0JBQVc7Z0JBQVc7Z0JBQVc7Z0JBQ3ZEO2dCQUFXO2dCQUFXO2dCQUFXO2dCQUFXO2dCQUFXO2dCQUN2RDtnQkFBVztnQkFBVztnQkFBVztnQkFBVztnQkFBVzthQUN4RDtZQUVELE1BQU1DLFNBQVMsQ0FBQztZQUNoQixNQUFNQyxhQUFhLElBQUlDO1lBRXZCSixjQUFjL0IsT0FBTyxDQUFDLENBQUNvQyxNQUFNbEM7Z0JBQzNCLElBQUltQyxhQUFhbkMsUUFBUThCLGFBQWE3QyxNQUFNO2dCQUM1QyxJQUFJbUQsV0FBVztnQkFFZixNQUFPSixXQUFXSyxHQUFHLENBQUNQLFlBQVksQ0FBQ0ssV0FBVyxLQUFLQyxXQUFXTixhQUFhN0MsTUFBTSxDQUFFO29CQUNqRmtELGFBQWEsQ0FBQ0EsYUFBYSxLQUFLTCxhQUFhN0MsTUFBTTtvQkFDbkRtRDtnQkFDRjtnQkFFQUwsTUFBTSxDQUFDRyxLQUFLLEdBQUdKLFlBQVksQ0FBQ0ssV0FBVztnQkFDdkNILFdBQVdNLEdBQUcsQ0FBQ1IsWUFBWSxDQUFDSyxXQUFXO1lBQ3pDO1lBRUEsT0FBT0o7UUFDVDtRQUVBLE1BQU1hLHFCQUFxQjhCLHFCQUFxQkMsT0FBT0MsSUFBSSxDQUFDL0M7UUFFNUQsTUFBTWdELGFBQWEsZzZGQTZDdUNKLE9BSkZELFdBQVUsdVRBb0JjRyxPQWhCdEJGLGFBQVksMG5DQXFCMURFLE9BTG9FQSxPQUFPQyxJQUFJLENBQUMvQyxlQUFlNUMsTUFBTSxFQUFDLHNQQVk1RixPQVBWMEYsT0FBT0csT0FBTyxDQUFDakQsZUFBZWtELElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNQSxDQUFDLENBQUMsRUFBRSxHQUFHRCxDQUFDLENBQUMsRUFBRSxFQUFFbkwsR0FBRyxDQUFDO2dCQUFDLENBQUNxSSxNQUFNZ0QsTUFBTTtZQUM1RSxNQUFNdEUsUUFBUWdDLGtCQUFrQixDQUFDVixLQUFLLElBQUk7WUFDMUMsT0FBTyxxS0FHMkJBLE9BRHlCdEIsT0FBTSx1R0FDdEJzRSxPQUFUaEQsTUFBSyxNQUFVLE9BQU5nRCxPQUFNO1FBRW5ELEdBQUdDLElBQUksQ0FBQyxLQUFJO1FBUXRCLE1BQU1DLGdCQUFnQjVMLFNBQVMrRCxhQUFhLENBQUM7UUFDN0M2SCxjQUFjQyxTQUFTLEdBQUdSO1FBQzFCckwsU0FBU3VFLElBQUksQ0FBQ0wsV0FBVyxDQUFDMEg7UUFFMUIvSyxPQUFPaUwsYUFBYSxHQUFHLFNBQVNDLFNBQVMsRUFBRUMsT0FBTztZQUNoRCxNQUFNQyxVQUFVak0sU0FBU0MsY0FBYyxDQUFDOEw7WUFDeEMsTUFBTUcsUUFBUWxNLFNBQVNDLGNBQWMsQ0FBQytMO1lBRXRDLElBQUlDLFFBQVF0SSxLQUFLLENBQUN3SSxPQUFPLEtBQUssUUFBUTtnQkFDcENGLFFBQVF0SSxLQUFLLENBQUN3SSxPQUFPLEdBQUc7Z0JBQ3hCRCxNQUFNbEksV0FBVyxHQUFHO1lBQ3RCLE9BQU87Z0JBQ0xpSSxRQUFRdEksS0FBSyxDQUFDd0ksT0FBTyxHQUFHO2dCQUN4QkQsTUFBTWxJLFdBQVcsR0FBRztZQUN0QjtRQUNGO1FBRUFuRCxPQUFPdUwsWUFBWSxHQUFHO1lBQ3BCLE1BQU1ILFVBQVVqTSxTQUFTQyxjQUFjLENBQUM7WUFDeEMsTUFBTWlNLFFBQVFsTSxTQUFTQyxjQUFjLENBQUM7WUFFdEMsSUFBSWdNLFFBQVF0SSxLQUFLLENBQUN3SSxPQUFPLEtBQUssUUFBUTtnQkFDcENGLFFBQVF0SSxLQUFLLENBQUN3SSxPQUFPLEdBQUc7Z0JBQ3hCRCxNQUFNbEksV0FBVyxHQUFHO1lBQ3RCLE9BQU87Z0JBQ0xpSSxRQUFRdEksS0FBSyxDQUFDd0ksT0FBTyxHQUFHO2dCQUN4QkQsTUFBTWxJLFdBQVcsR0FBRztZQUN0QjtRQUNGO1FBRUEsSUFBSXRCLGFBQWE7UUFDakIsSUFBSUM7UUFDSixJQUFJQztRQUNKLElBQUlDO1FBQ0osSUFBSUM7UUFDSixJQUFJQyxVQUFVO1FBQ2QsSUFBSUMsVUFBVTtRQUVkLE1BQU1xSixTQUFTck0sU0FBU0MsY0FBYyxDQUFDO1FBQ3ZDLE1BQU1xTSxTQUFTdE0sU0FBU0MsY0FBYyxDQUFDO1FBRXZDcU0sT0FBT3JKLGdCQUFnQixDQUFDLGFBQWFDO1FBQ3JDbEQsU0FBU2lELGdCQUFnQixDQUFDLGFBQWFFO1FBQ3ZDbkQsU0FBU2lELGdCQUFnQixDQUFDLFdBQVdHO1FBRXJDLFNBQVNGLFVBQVVHLENBQUM7WUFDbEIsSUFBSUEsRUFBRUMsTUFBTSxDQUFDaUosRUFBRSxLQUFLLHVCQUF1QjtZQUUzQzFKLFdBQVdRLEVBQUVHLE9BQU8sR0FBR1Q7WUFDdkJELFdBQVdPLEVBQUVJLE9BQU8sR0FBR1Q7WUFFdkIsSUFBSUssRUFBRUMsTUFBTSxLQUFLZ0osVUFBVUEsT0FBTzVJLFFBQVEsQ0FBQ0wsRUFBRUMsTUFBTSxHQUFHO2dCQUNwRFosYUFBYTtZQUNmO1FBQ0Y7UUFFQSxTQUFTUyxLQUFLRSxDQUFDO1lBQ2IsSUFBSVgsWUFBWTtnQkFDZFcsRUFBRVEsY0FBYztnQkFDaEJsQixXQUFXVSxFQUFFRyxPQUFPLEdBQUdYO2dCQUN2QkQsV0FBV1MsRUFBRUksT0FBTyxHQUFHWDtnQkFFdkJDLFVBQVVKO2dCQUNWSyxVQUFVSjtnQkFFVnlKLE9BQU8xSSxLQUFLLENBQUNHLFNBQVMsR0FBRyxlQUE4QmxCLE9BQWZELFVBQVMsUUFBZSxPQUFUQyxVQUFTO1lBQ2xFO1FBQ0Y7UUFFQSxTQUFTUSxRQUFRQyxDQUFDO1lBQ2hCUixXQUFXRjtZQUNYRyxXQUFXRjtZQUNYRixhQUFhO1FBQ2Y7UUFFQXhDLFFBQVFDLEdBQUcsQ0FBQztJQUNkO0lBRUEsSUFBSXZCLE9BQU87UUFDVCxxQkFDRSw4REFBQzROO1lBQUk3SSxPQUFPO2dCQUNWckIsVUFBVTtnQkFDVm1LLEtBQUs7Z0JBQ0xDLE1BQU07Z0JBQ041SSxXQUFXO2dCQUNYNkksUUFBUTtnQkFDUkMsWUFBWTtnQkFDWnJDLFNBQVM7Z0JBQ1RzQyxjQUFjO2dCQUNkQyxXQUFXO2dCQUNYMUYsT0FBTztZQUNUOzs4QkFDRSw4REFBQzJGOzhCQUFHOzs7Ozs7OEJBQ0osOERBQUNDOzt3QkFBRTt3QkFBUXBPOzs7Ozs7Ozs7Ozs7O0lBR2pCO0lBRUFzQixRQUFRQyxHQUFHLENBQUMsaUJBQWlCO1FBQzNCL0IsZUFBZUEsQ0FBQUEsMEJBQUFBLHFDQUFBQSwyQkFBQUEsY0FBZW9ILFNBQVMsY0FBeEJwSCwrQ0FBQUEseUJBQTBCcUgsTUFBTSxLQUFJO1FBQ25EcEgsY0FBY0EsQ0FBQUEseUJBQUFBLG9DQUFBQSx5QkFBQUEsYUFBY3FILFFBQVEsY0FBdEJySCw2Q0FBQUEsdUJBQXdCb0gsTUFBTSxLQUFJO1FBQ2hEL0c7UUFDQUUsT0FBTyxDQUFDLENBQUNBO0lBQ1g7SUFFQSxxQkFDRSw4REFBQzROO1FBQUk3SSxPQUFPO1lBQUVyQixVQUFVO1lBQVkySyxPQUFPO1lBQVFDLFFBQVE7UUFBUTs7MEJBQ2pFLDhEQUFDVjtnQkFDQ1csV0FBVTtnQkFDVlosSUFBRztnQkFDSGEsS0FBSzlPO2dCQUNMcUYsT0FBTztvQkFDTHNKLE9BQU87b0JBQ1BDLFFBQVE7b0JBQ1JHLFdBQVc7b0JBQ1gvSyxVQUFVO29CQUNWbUssS0FBSztvQkFDTEMsTUFBTTtvQkFDTkMsUUFBUTtnQkFDVjs7Ozs7O1lBRURqTyx5QkFDQyw4REFBQzhOO2dCQUFJN0ksT0FBTztvQkFDVnJCLFVBQVU7b0JBQ1ZtSyxLQUFLO29CQUNMQyxNQUFNO29CQUNONUksV0FBVztvQkFDWDZJLFFBQVE7b0JBQ1JDLFlBQVk7b0JBQ1pyQyxTQUFTO29CQUNUc0MsY0FBYztvQkFDZEMsV0FBVztnQkFDYjs7a0NBQ0UsOERBQUNDO2tDQUFHOzs7Ozs7a0NBQ0osOERBQUNDO2tDQUFFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFLYjtHQXIvQndCN087O1FBSzRESixvREFBUUE7UUFLWEEsb0RBQVFBOzs7S0FWakVJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvTWFwQ29tcG9uZW50LmpzP2QwN2QiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlUXVlcnkgfSBmcm9tICdAYXBvbGxvL2NsaWVudCc7XG5pbXBvcnQgeyBncWwgfSBmcm9tICdAYXBvbGxvL2NsaWVudCc7XG5cbi8vIEdyYXBoUUwgcXVlcmllc1xuY29uc3QgR0VUX0xPQ0FUSU9OUyA9IGdxbGBcbiAgcXVlcnkgR2V0TG9jYXRpb25zIHtcbiAgICBsb2NhdGlvbnMge1xuICAgICAgbG9jYXRpb25faWRcbiAgICAgIGxvY2F0aW9uX25hbWVcbiAgICAgIGxhdGl0dWRlXG4gICAgICBsb25naXR1ZGVcbiAgICAgIGVsZXZhdGlvbl9tXG4gICAgICB1bml0X3R5cGVcbiAgICAgIGxvY2F0aW9uX2NhdGVnb3J5XG4gICAgICBwaXRfbmFtZVxuICAgICAgcmVnaW9uX25hbWVcbiAgICB9XG4gIH1cbmA7XG5cbmNvbnN0IEdFVF9TRUdNRU5UUyA9IGdxbGBcbiAgcXVlcnkgR2V0U2VnbWVudHMoJGxpbWl0OiBJbnQpIHtcbiAgICBzZWdtZW50cyhsaW1pdDogJGxpbWl0KSB7XG4gICAgICBsYW5lX2lkXG4gICAgICByb2FkX2lkXG4gICAgICBkaXJlY3Rpb25cbiAgICAgIGxlbmd0aF9tXG4gICAgICB0aW1lX2VtcHR5X3NlY29uZHNcbiAgICAgIHRpbWVfbG9hZGVkX3NlY29uZHNcbiAgICAgIGlzX2Nsb3NlZFxuICAgICAgZ2VvbWV0cnlcbiAgICAgIHN0YXJ0X2xhdGl0dWRlXG4gICAgICBzdGFydF9sb25naXR1ZGVcbiAgICAgIGVuZF9sYXRpdHVkZVxuICAgICAgZW5kX2xvbmdpdHVkZVxuICAgIH1cbiAgfVxuYDtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTWFwQ29tcG9uZW50KCkge1xuICBjb25zdCBtYXBSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IG1hcEluc3RhbmNlUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBtYXBJbml0aWFsaXplZFJlZiA9IHVzZVJlZihmYWxzZSk7XG4gIFxuICBjb25zdCB7IGRhdGE6IGxvY2F0aW9uc0RhdGEsIGxvYWRpbmc6IGxvY2F0aW9uc0xvYWRpbmcsIGVycm9yOiBsb2NhdGlvbnNFcnJvciB9ID0gdXNlUXVlcnkoR0VUX0xPQ0FUSU9OUywge1xuICAgIGZldGNoUG9saWN5OiAnY2FjaGUtYW5kLW5ldHdvcmsnLFxuICAgIGVycm9yUG9saWN5OiAnYWxsJ1xuICB9KTtcblxuICBjb25zdCB7IGRhdGE6IHNlZ21lbnRzRGF0YSwgbG9hZGluZzogc2VnbWVudHNMb2FkaW5nLCBlcnJvcjogc2VnbWVudHNFcnJvciB9ID0gdXNlUXVlcnkoR0VUX1NFR01FTlRTLCB7XG4gICAgdmFyaWFibGVzOiB7IGxpbWl0OiAxMDAwMDAgfSwgXG4gICAgZmV0Y2hQb2xpY3k6ICdjYWNoZS1hbmQtbmV0d29yaycsXG4gICAgZXJyb3JQb2xpY3k6ICdhbGwnXG4gIH0pO1xuXG4gIGNvbnN0IGxvYWRpbmcgPSBsb2NhdGlvbnNMb2FkaW5nIHx8IHNlZ21lbnRzTG9hZGluZztcbiAgY29uc3QgZXJyb3IgPSBsb2NhdGlvbnNFcnJvciB8fCBzZWdtZW50c0Vycm9yO1xuXG4gIGNvbnN0IHJlc2V0Q29tcG9uZW50U3RhdGUgPSAoKSA9PiB7XG4gICAgbWFwSW5pdGlhbGl6ZWRSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgIGlmIChtYXBJbnN0YW5jZVJlZi5jdXJyZW50KSB7XG4gICAgICBtYXBJbnN0YW5jZVJlZi5jdXJyZW50LnJlbW92ZSgpO1xuICAgICAgbWFwSW5zdGFuY2VSZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmVzZXRDb21wb25lbnRTdGF0ZSgpO1xuICB9LCBbXSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcbiAgICBcbiAgICBtYXBJbml0aWFsaXplZFJlZi5jdXJyZW50ID0gZmFsc2U7XG5cbiAgICBjb25zdCBsb2FkTWFwID0gYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgTCA9IChhd2FpdCBpbXBvcnQoJ2xlYWZsZXQnKSkuZGVmYXVsdDtcbiAgICAgIFxuICAgICAgbGV0IG1hcENvbnRhaW5lciA9IG51bGw7XG4gICAgICBsZXQgcmV0cmllcyA9IDA7XG4gICAgICBjb25zdCBtYXhSZXRyaWVzID0gMTA7XG4gICAgICBcbiAgICAgIHdoaWxlICghbWFwQ29udGFpbmVyICYmIHJldHJpZXMgPCBtYXhSZXRyaWVzKSB7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAyMDApKTtcbiAgICAgICAgbWFwQ29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21hcCcpO1xuICAgICAgICBpZiAoIW1hcENvbnRhaW5lcikge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBNYXAgY29udGFpbmVyIG5vdCBmb3VuZCwgcmV0cnlpbmcuLi4gKCR7cmV0cmllcyArIDF9LyR7bWF4UmV0cmllc30pYCk7XG4gICAgICAgICAgcmV0cmllcysrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmICghbWFwQ29udGFpbmVyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ01hcCBjb250YWluZXIgbm90IGZvdW5kIGFmdGVyIGFsbCByZXRyaWVzJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ+KchSBNYXAgY29udGFpbmVyIGZvdW5kLCBpbml0aWFsaXppbmcgbWFwLi4uJyk7XG5cbiAgICAgIGlmIChtYXBJbnN0YW5jZVJlZi5jdXJyZW50KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdSZW1vdmluZyBleGlzdGluZyBtYXAuLi4nKTtcbiAgICAgICAgbWFwSW5zdGFuY2VSZWYuY3VycmVudC5yZW1vdmUoKTtcbiAgICAgICAgbWFwSW5zdGFuY2VSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChtYXBDb250YWluZXIgJiYgbWFwQ29udGFpbmVyLl9sZWFmbGV0X2lkKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdDbGVhcmluZyBleGlzdGluZyBsZWFmbGV0IElELi4uJyk7XG4gICAgICAgIGRlbGV0ZSBtYXBDb250YWluZXIuX2xlYWZsZXRfaWQ7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1hcCA9IEwubWFwKCdtYXAnLCB7XG4gICAgICAgIGNlbnRlcjogWy0yMy41LCAxNDguNV0sXG4gICAgICAgIGNyczogTC5DUlMuRVBTRzM4NTcsXG4gICAgICAgIHpvb206IDEyLFxuICAgICAgICB6b29tQ29udHJvbDogdHJ1ZSxcbiAgICAgICAgcHJlZmVyQ2FudmFzOiBmYWxzZSxcbiAgICAgIH0pO1xuICAgICAgbWFwSW5zdGFuY2VSZWYuY3VycmVudCA9IG1hcDtcbiAgICAgIG1hcEluaXRpYWxpemVkUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgY29uc29sZS5sb2coJ+KchSBNYXAgaW5pdGlhbGl6ZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gICAgICBcbiAgICAgIHdpbmRvdy5tYXAgPSBtYXA7XG4gICAgICB3aW5kb3cubV9iZXppZXIgPSBtYXA7XG4gICAgICBcbiAgICAgIGNvbnN0IHRpbGVfbGF5ZXJfODZhZjQxMWZjYWExNGIyZTg5MTQ0NjZiNTIwMDk2MzMgPSBMLnRpbGVMYXllcihcbiAgICAgICAgXCJodHRwczovL2FwaS5tYXBib3guY29tL3N0eWxlcy92MS9tYXBib3gvc2F0ZWxsaXRlLXN0cmVldHMtdjExL3RpbGVzL3t6fS97eH0ve3l9P2FjY2Vzc190b2tlbj1way5leUoxSWpvaVkyOTFjSE4wWlhJM05DSXNJbUVpT2lKamEyeHdkalJ3YVdZd2MyUTJNbTlzWW1wcmJ6aHVlbmcySW4wLnAtRmJrYkJoSldCS1ctZXZXWmZtZ3dcIixcbiAgICAgICAge1xuICAgICAgICAgIG1pblpvb206IDAsXG4gICAgICAgICAgbWF4Wm9vbTogMTgsXG4gICAgICAgICAgbWF4TmF0aXZlWm9vbTogMTgsXG4gICAgICAgICAgbm9XcmFwOiBmYWxzZSxcbiAgICAgICAgICBhdHRyaWJ1dGlvbjogXCJNYXBib3hcIixcbiAgICAgICAgICBzdWJkb21haW5zOiBcImFiY1wiLFxuICAgICAgICAgIGRldGVjdFJldGluYTogZmFsc2UsXG4gICAgICAgICAgdG1zOiBmYWxzZSxcbiAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICB9XG4gICAgICApO1xuICAgICAgdGlsZV9sYXllcl84NmFmNDExZmNhYTE0YjJlODkxNDQ2NmI1MjAwOTYzMy5hZGRUbyhtYXApO1xuXG4gICAgICBjb25zdCB0aWxlX2xheWVyXzY1MWMyMTdlOTE1OTljNzg4YzFkMmY0ZGRjZWUyMmVmID0gTC50aWxlTGF5ZXIoXG4gICAgICAgIFwiaHR0cHM6Ly9hcGkubWFwYm94LmNvbS9zdHlsZXMvdjEvbWFwYm94L291dGRvb3JzLXYxMS90aWxlcy97en0ve3h9L3t5fT9hY2Nlc3NfdG9rZW49cGsuZXlKMUlqb2lZMjkxY0hOMFpYSTNOQ0lzSW1FaU9pSmphMnh3ZGpSd2FXWXdjMlEyTW05c1ltcHJiemh1ZW5nMkluMC5wLUZia2JCaEpXQktXLWV2V1pmbWd3XCIsXG4gICAgICAgIHtcbiAgICAgICAgICBtaW5ab29tOiAwLFxuICAgICAgICAgIG1heFpvb206IDE4LFxuICAgICAgICAgIG1heE5hdGl2ZVpvb206IDE4LFxuICAgICAgICAgIG5vV3JhcDogZmFsc2UsXG4gICAgICAgICAgYXR0cmlidXRpb246IFwiTWFwYm94XCIsXG4gICAgICAgICAgc3ViZG9tYWluczogXCJhYmNcIixcbiAgICAgICAgICBkZXRlY3RSZXRpbmE6IGZhbHNlLFxuICAgICAgICAgIHRtczogZmFsc2UsXG4gICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgfVxuICAgICAgKTtcblxuICAgICAgY29uc3QgdGlsZV9sYXllcl8xYWVhMGE5NDk3OGVjZjRkN2YxY2UwMDk2YTY5Mjc0MSA9IEwudGlsZUxheWVyKFxuICAgICAgICBcImh0dHBzOi8vYXBpLm1hcGJveC5jb20vc3R5bGVzL3YxL21hcGJveC9zdHJlZXRzLXYxMS90aWxlcy97en0ve3h9L3t5fT9hY2Nlc3NfdG9rZW49cGsuZXlKMUlqb2lZMjkxY0hOMFpYSTNOQ0lzSW1FaU9pSmphMnh3ZGpSd2FXWXdjMlEyTW05c1ltcHJiemh1ZW5nMkluMC5wLUZia2JCaEpXQktXLWV2V1pmbWd3XCIsXG4gICAgICAgIHtcbiAgICAgICAgICBtaW5ab29tOiAwLFxuICAgICAgICAgIG1heFpvb206IDE4LFxuICAgICAgICAgIG1heE5hdGl2ZVpvb206IDE4LFxuICAgICAgICAgIG5vV3JhcDogZmFsc2UsXG4gICAgICAgICAgYXR0cmlidXRpb246IFwiTWFwYm94XCIsXG4gICAgICAgICAgc3ViZG9tYWluczogXCJhYmNcIixcbiAgICAgICAgICBkZXRlY3RSZXRpbmE6IGZhbHNlLFxuICAgICAgICAgIHRtczogZmFsc2UsXG4gICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgfVxuICAgICAgKTtcblxuICAgICAgY29uc3QgdGlsZV9sYXllcl9iZGIyNzhiZmQ3YmY0NWJkM2YxYjdlM2YxMmE2ZmRkMyA9IEwudGlsZUxheWVyKFxuICAgICAgICBcImh0dHBzOi8vYXBpLm1hcGJveC5jb20vc3R5bGVzL3YxL21hcGJveC9zYXRlbGxpdGUtdjkvdGlsZXMve3p9L3t4fS97eX0/YWNjZXNzX3Rva2VuPXBrLmV5SjFJam9pWTI5MWNITjBaWEkzTkNJc0ltRWlPaUpqYTJ4d2RqUndhV1l3YzJRMk1tOXNZbXByYnpodWVuZzJJbjAucC1GYmtiQmhKV0JLVy1ldldaZm1nd1wiLFxuICAgICAgICB7XG4gICAgICAgICAgbWluWm9vbTogMCxcbiAgICAgICAgICBtYXhab29tOiAyMixcbiAgICAgICAgICBtYXhOYXRpdmVab29tOiAyMixcbiAgICAgICAgICBub1dyYXA6IGZhbHNlLFxuICAgICAgICAgIGF0dHJpYnV0aW9uOiBcIk1hcGJveFwiLFxuICAgICAgICAgIHN1YmRvbWFpbnM6IFwiYWJjXCIsXG4gICAgICAgICAgZGV0ZWN0UmV0aW5hOiBmYWxzZSxcbiAgICAgICAgICB0bXM6IGZhbHNlLFxuICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgIH1cbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHRpbGVfbGF5ZXJfZWY5MTVhYjkyZTBkZGNiOWU4NDA5NTVhOWQ0NDIwZjUgPSBMLnRpbGVMYXllcihcbiAgICAgICAgXCJodHRwczovL2FwaS5tYXBib3guY29tL3N0eWxlcy92MS9tYXBib3gvc3RhbmRhcmQvdGlsZXMve3p9L3t4fS97eX1AMng/YWNjZXNzX3Rva2VuPXBrLmV5SjFJam9pWTI5MWNITjBaWEkzTkNJc0ltRWlPaUpqYTJ4d2RqUndhV1l3YzJRMk1tOXNZbXByYnpodWVuZzJJbjAucC1GYmtiQmhKV0JLVy1ldldaZm1nd1wiLFxuICAgICAgICB7XG4gICAgICAgICAgbWluWm9vbTogMCxcbiAgICAgICAgICBtYXhab29tOiAyMixcbiAgICAgICAgICBtYXhOYXRpdmVab29tOiAyMixcbiAgICAgICAgICBub1dyYXA6IGZhbHNlLFxuICAgICAgICAgIGF0dHJpYnV0aW9uOiBcIk1hcGJveFwiLFxuICAgICAgICAgIHN1YmRvbWFpbnM6IFwiYWJjXCIsXG4gICAgICAgICAgZGV0ZWN0UmV0aW5hOiBmYWxzZSxcbiAgICAgICAgICB0bXM6IGZhbHNlLFxuICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgIH1cbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHRpbGVfbGF5ZXJfZWMwZTI2NmRhY2RkOWFlODc5MjE1M2UwMDIwNGY0NDAgPSBMLnRpbGVMYXllcihcbiAgICAgICAgXCJodHRwczovL2FwaS5tYXBib3guY29tL3N0eWxlcy92MS9tYXBib3gvZGFyay12MTAvdGlsZXMve3p9L3t4fS97eX0/YWNjZXNzX3Rva2VuPXBrLmV5SjFJam9pWTI5MWNITjBaWEkzTkNJc0ltRWlPaUpqYTJ4d2RqUndhV1l3YzJRMk1tOXNZbXByYnpodWVuZzJJbjAucC1GYmtiQmhKV0JLVy1ldldaZm1nd1wiLFxuICAgICAgICB7XG4gICAgICAgICAgbWluWm9vbTogMCxcbiAgICAgICAgICBtYXhab29tOiAyMixcbiAgICAgICAgICBtYXhOYXRpdmVab29tOiAyMixcbiAgICAgICAgICBub1dyYXA6IGZhbHNlLFxuICAgICAgICAgIGF0dHJpYnV0aW9uOiBcIk1hcGJveFwiLFxuICAgICAgICAgIHN1YmRvbWFpbnM6IFwiYWJjXCIsXG4gICAgICAgICAgZGV0ZWN0UmV0aW5hOiBmYWxzZSxcbiAgICAgICAgICB0bXM6IGZhbHNlLFxuICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgIH1cbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHRpbGVfbGF5ZXJfOTgwYjc2OTFiMzlhY2U4NmY1YmM1YTliMWE3MzgzODkgPSBMLnRpbGVMYXllcihcbiAgICAgICAgXCJodHRwczovL2FwaS5tYXBib3guY29tL3N0eWxlcy92MS9tYXBib3gvbmF2aWdhdGlvbi1uaWdodC12MS90aWxlcy97en0ve3h9L3t5fT9hY2Nlc3NfdG9rZW49cGsuZXlKMUlqb2lZMjkxY0hOMFpYSTNOQ0lzSW1FaU9pSmphMnh3ZGpSd2FXWXdjMlEyTW05c1ltcHJiemh1ZW5nMkluMC5wLUZia2JCaEpXQktXLWV2V1pmbWd3XCIsXG4gICAgICAgIHtcbiAgICAgICAgICBtaW5ab29tOiAwLFxuICAgICAgICAgIG1heFpvb206IDIyLFxuICAgICAgICAgIG1heE5hdGl2ZVpvb206IDIyLFxuICAgICAgICAgIG5vV3JhcDogZmFsc2UsXG4gICAgICAgICAgYXR0cmlidXRpb246IFwiTWFwYm94XCIsXG4gICAgICAgICAgc3ViZG9tYWluczogXCJhYmNcIixcbiAgICAgICAgICBkZXRlY3RSZXRpbmE6IGZhbHNlLFxuICAgICAgICAgIHRtczogZmFsc2UsXG4gICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgfVxuICAgICAgKTtcblxuICAgICAgY29uc3QgdGlsZV9sYXllcl80Mzc4Yjc0NDI3MmEyMmY3OGMxNGM5ZTgwYjgzMGViOCA9IEwudGlsZUxheWVyKFxuICAgICAgICBcImh0dHBzOi8vYXBpLm1hcGJveC5jb20vc3R5bGVzL3YxL21hcGJveC9kYXJrLXYxMC90aWxlcy97en0ve3h9L3t5fT9hY2Nlc3NfdG9rZW49cGsuZXlKMUlqb2lZMjkxY0hOMFpYSTNOQ0lzSW1FaU9pSmphMnh3ZGpSd2FXWXdjMlEyTW05c1ltcHJiemh1ZW5nMkluMC5wLUZia2JCaEpXQktXLWV2V1pmbWd3XCIsXG4gICAgICAgIHtcbiAgICAgICAgICBtaW5ab29tOiAwLFxuICAgICAgICAgIG1heFpvb206IDIyLFxuICAgICAgICAgIG1heE5hdGl2ZVpvb206IDIyLFxuICAgICAgICAgIG5vV3JhcDogZmFsc2UsXG4gICAgICAgICAgYXR0cmlidXRpb246IFwiTWFwYm94XCIsXG4gICAgICAgICAgc3ViZG9tYWluczogXCJhYmNcIixcbiAgICAgICAgICBkZXRlY3RSZXRpbmE6IGZhbHNlLFxuICAgICAgICAgIHRtczogZmFsc2UsXG4gICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgfVxuICAgICAgKTtcblxuICAgICAgY29uc3QgYmFzZUxheWVycyA9IHtcbiAgICAgICAgXCJTYXRlbGxpdGUgU3RyZWV0c1wiOiB0aWxlX2xheWVyXzg2YWY0MTFmY2FhMTRiMmU4OTE0NDY2YjUyMDA5NjMzLFxuICAgICAgICBcIlRvcG9ncmFwaGljXCI6IHRpbGVfbGF5ZXJfNjUxYzIxN2U5MTU5OWM3ODhjMWQyZjRkZGNlZTIyZWYsXG4gICAgICAgIFwiU3RyZWV0c1wiOiB0aWxlX2xheWVyXzFhZWEwYTk0OTc4ZWNmNGQ3ZjFjZTAwOTZhNjkyNzQxLFxuICAgICAgICBcIlNhdGVsbGl0ZVwiOiB0aWxlX2xheWVyX2JkYjI3OGJmZDdiZjQ1YmQzZjFiN2UzZjEyYTZmZGQzLFxuICAgICAgICBcIlN0YW5kYXJkXCI6IHRpbGVfbGF5ZXJfZWY5MTVhYjkyZTBkZGNiOWU4NDA5NTVhOWQ0NDIwZjUsXG4gICAgICAgIFwiRGFya1wiOiB0aWxlX2xheWVyX2VjMGUyNjZkYWNkZDlhZTg3OTIxNTNlMDAyMDRmNDQwLFxuICAgICAgICBcIlRvcG9ncmFwaGljIERhcmtcIjogdGlsZV9sYXllcl85ODBiNzY5MWIzOWFjZTg2ZjViYzVhOWIxYTczODM4OSxcbiAgICAgICAgXCJTdHJlZXRzIERhcmtcIjogdGlsZV9sYXllcl80Mzc4Yjc0NDI3MmEyMmY3OGMxNGM5ZTgwYjgzMGViOFxuICAgICAgfTtcblxuICAgICAgY29uc3QgbGF5ZXJDb250cm9sID0gTC5jb250cm9sLmxheWVycyhiYXNlTGF5ZXJzLCB7fSwge1xuICAgICAgICBwb3NpdGlvbjogJ3RvcGxlZnQnLFxuICAgICAgICBjb2xsYXBzZWQ6IHRydWVcbiAgICAgIH0pLmFkZFRvKG1hcCk7XG4gICAgICBcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjb25zdCBsYXllckNvbnRyb2xFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmxlYWZsZXQtY29udHJvbC1sYXllcnMnKTtcbiAgICAgICAgaWYgKGxheWVyQ29udHJvbEVsZW1lbnQpIHtcbiAgICAgICAgICBsZXQgaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgIGxldCBjdXJyZW50WDtcbiAgICAgICAgICBsZXQgY3VycmVudFk7XG4gICAgICAgICAgbGV0IGluaXRpYWxYO1xuICAgICAgICAgIGxldCBpbml0aWFsWTtcbiAgICAgICAgICBsZXQgeE9mZnNldCA9IDA7XG4gICAgICAgICAgbGV0IHlPZmZzZXQgPSAwO1xuICAgICAgICAgIFxuICAgICAgICAgIGxheWVyQ29udHJvbEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgZHJhZ1N0YXJ0KTtcbiAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBkcmFnKTtcbiAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgZHJhZ0VuZCk7XG4gICAgICAgICAgXG4gICAgICAgICAgZnVuY3Rpb24gZHJhZ1N0YXJ0KGUpIHtcbiAgICAgICAgICAgIGlmIChlLnRhcmdldC5jbG9zZXN0KCcubGVhZmxldC1jb250cm9sLWxheWVycy1leHBhbmRlZCcpKSByZXR1cm47IC8vIERvbid0IGRyYWcgd2hlbiBkcm9wZG93biBpcyBvcGVuXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGluaXRpYWxYID0gZS5jbGllbnRYIC0geE9mZnNldDtcbiAgICAgICAgICAgIGluaXRpYWxZID0gZS5jbGllbnRZIC0geU9mZnNldDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGUudGFyZ2V0ID09PSBsYXllckNvbnRyb2xFbGVtZW50IHx8IGxheWVyQ29udHJvbEVsZW1lbnQuY29udGFpbnMoZS50YXJnZXQpKSB7XG4gICAgICAgICAgICAgIGlzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICBsYXllckNvbnRyb2xFbGVtZW50LnN0eWxlLmN1cnNvciA9ICdncmFiYmluZyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGZ1bmN0aW9uIGRyYWcoZSkge1xuICAgICAgICAgICAgaWYgKGlzRHJhZ2dpbmcpIHtcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICBjdXJyZW50WCA9IGUuY2xpZW50WCAtIGluaXRpYWxYO1xuICAgICAgICAgICAgICBjdXJyZW50WSA9IGUuY2xpZW50WSAtIGluaXRpYWxZO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgeE9mZnNldCA9IGN1cnJlbnRYO1xuICAgICAgICAgICAgICB5T2Zmc2V0ID0gY3VycmVudFk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBsYXllckNvbnRyb2xFbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgke2N1cnJlbnRYfXB4LCAke2N1cnJlbnRZfXB4LCAwKWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGZ1bmN0aW9uIGRyYWdFbmQoZSkge1xuICAgICAgICAgICAgaW5pdGlhbFggPSBjdXJyZW50WDtcbiAgICAgICAgICAgIGluaXRpYWxZID0gY3VycmVudFk7XG4gICAgICAgICAgICBpc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBsYXllckNvbnRyb2xFbGVtZW50LnN0eWxlLmN1cnNvciA9ICdtb3ZlJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIDEwMCk7XG4gICAgICBcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjb25zdCBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgIHN0eWxlLnRleHRDb250ZW50ID0gYFxuICAgICAgICAgIC5sZWFmbGV0LWNvbnRyb2wtem9vbSB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDYwLCA2MCwgNjAsIDAuOSkgIWltcG9ydGFudDtcbiAgICAgICAgICAgIGJvcmRlcjogMXB4IHNvbGlkIHJnYmEoMTIwLCAxMjAsIDEyMCwgMC41KSAhaW1wb3J0YW50O1xuICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogNnB4ICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICBib3gtc2hhZG93OiAwIDJweCA4cHggcmdiYSgwLDAsMCwwLjMpICFpbXBvcnRhbnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLmxlYWZsZXQtY29udHJvbC16b29tIGEge1xuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSg2MCwgNjAsIDYwLCAwLjkpICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICBjb2xvcjogd2hpdGUgIWltcG9ydGFudDtcbiAgICAgICAgICAgIGJvcmRlcjogbm9uZSAhaW1wb3J0YW50O1xuICAgICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQgIWltcG9ydGFudDtcbiAgICAgICAgICAgIHRleHQtc2hhZG93OiAwIDFweCAycHggcmdiYSgwLDAsMCwwLjUpICFpbXBvcnRhbnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLmxlYWZsZXQtY29udHJvbC16b29tIGE6aG92ZXIge1xuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSg4MCwgODAsIDgwLCAwLjkpICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICBjb2xvcjogI2JkYzNjNyAhaW1wb3J0YW50O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzIHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBmaXhlZCAhaW1wb3J0YW50O1xuICAgICAgICAgICAgdG9wOiAyMHB4ICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICBsZWZ0OiA1MCUgIWltcG9ydGFudDtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtNTAlKSAhaW1wb3J0YW50O1xuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSg2MCwgNjAsIDYwLCAwLjkpICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICBib3JkZXI6IDFweCBzb2xpZCByZ2JhKDEyMCwgMTIwLCAxMjAsIDAuNSkgIWltcG9ydGFudDtcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDZweCAhaW1wb3J0YW50O1xuICAgICAgICAgICAgYm94LXNoYWRvdzogMCA0cHggMTJweCByZ2JhKDAsMCwwLDAuNCkgIWltcG9ydGFudDtcbiAgICAgICAgICAgIGJhY2tkcm9wLWZpbHRlcjogYmx1cigxMHB4KSAhaW1wb3J0YW50O1xuICAgICAgICAgICAgei1pbmRleDogMTAwMCAhaW1wb3J0YW50O1xuICAgICAgICAgICAgY3Vyc29yOiBtb3ZlICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICBtaW4td2lkdGg6IDEyMHB4ICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICBtYXgtd2lkdGg6IDIwMHB4ICFpbXBvcnRhbnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLmxlYWZsZXQtY29udHJvbC1sYXllcnMtdG9nZ2xlIHtcbiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoNjAsIDYwLCA2MCwgMC45KSAhaW1wb3J0YW50O1xuICAgICAgICAgICAgYm9yZGVyOiAxcHggc29saWQgcmdiYSgxMjAsIDEyMCwgMTIwLCAwLjUpICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICBib3JkZXItcmFkaXVzOiA2cHggIWltcG9ydGFudDtcbiAgICAgICAgICAgIGNvbG9yOiB3aGl0ZSAhaW1wb3J0YW50O1xuICAgICAgICAgICAgZm9udC13ZWlnaHQ6IDYwMCAhaW1wb3J0YW50O1xuICAgICAgICAgICAgdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZSAhaW1wb3J0YW50O1xuICAgICAgICAgICAgZm9udC1zaXplOiAxMHB4ICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICBwYWRkaW5nOiA2cHggOHB4ICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICBtaW4td2lkdGg6IDEwMHB4ICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXIgIWltcG9ydGFudDtcbiAgICAgICAgICAgIGRpc3BsYXk6IGZsZXggIWltcG9ydGFudDtcbiAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXIgIWltcG9ydGFudDtcbiAgICAgICAgICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbiAhaW1wb3J0YW50O1xuICAgICAgICAgICAgY3Vyc29yOiBtb3ZlICFpbXBvcnRhbnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLmxlYWZsZXQtY29udHJvbC1sYXllcnMtdG9nZ2xlOjpiZWZvcmUge1xuICAgICAgICAgICAgY29udGVudDogXCLwn5e677iPXCIgIWltcG9ydGFudDtcbiAgICAgICAgICAgIG1hcmdpbi1yaWdodDogNHB4ICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICBmb250LXNpemU6IDEycHggIWltcG9ydGFudDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAubGVhZmxldC1jb250cm9sLWxheWVycy10b2dnbGU6OmFmdGVyIHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IFwi4pa8XCIgIWltcG9ydGFudDtcbiAgICAgICAgICAgIG1hcmdpbi1sZWZ0OiA0cHggIWltcG9ydGFudDtcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogOHB4ICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC4zcyBlYXNlICFpbXBvcnRhbnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLmxlYWZsZXQtY29udHJvbC1sYXllcnMtZXhwYW5kZWQge1xuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjk1KSAhaW1wb3J0YW50O1xuICAgICAgICAgICAgY29sb3I6ICMzMzMgIWltcG9ydGFudDtcbiAgICAgICAgICAgIGJvcmRlcjogMXB4IHNvbGlkIHJnYmEoMjAwLCAyMDAsIDIwMCwgMC44KSAhaW1wb3J0YW50O1xuICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogNnB4ICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICBib3gtc2hhZG93OiAwIDRweCAxMnB4IHJnYmEoMCwwLDAsMC4zKSAhaW1wb3J0YW50O1xuICAgICAgICAgICAgYmFja2Ryb3AtZmlsdGVyOiBibHVyKDEwcHgpICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICBtYXJnaW4tdG9wOiA0cHggIWltcG9ydGFudDtcbiAgICAgICAgICAgIHBhZGRpbmc6IDZweCAwICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICBtaW4td2lkdGg6IDEyMHB4ICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICBtYXgtd2lkdGg6IDIwMHB4ICFpbXBvcnRhbnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLmxlYWZsZXQtY29udHJvbC1sYXllcnMgbGFiZWwge1xuICAgICAgICAgICAgY29sb3I6ICMzMzMgIWltcG9ydGFudDtcbiAgICAgICAgICAgIHBhZGRpbmc6IDRweCA4cHggIWltcG9ydGFudDtcbiAgICAgICAgICAgIG1hcmdpbjogMCAhaW1wb3J0YW50O1xuICAgICAgICAgICAgZm9udC1zaXplOiAxMXB4ICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICBjdXJzb3I6IHBvaW50ZXIgIWltcG9ydGFudDtcbiAgICAgICAgICAgIHRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgMC4ycyBlYXNlICFpbXBvcnRhbnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLmxlYWZsZXQtY29udHJvbC1sYXllcnMgbGFiZWw6aG92ZXIge1xuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSg2MCwgNjAsIDYwLCAwLjEpICFpbXBvcnRhbnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLmxlYWZsZXQtY29udHJvbC1sYXllcnMgaW5wdXRbdHlwZT1cInJhZGlvXCJdIHtcbiAgICAgICAgICAgIGFjY2VudC1jb2xvcjogIzM0OThkYiAhaW1wb3J0YW50O1xuICAgICAgICAgICAgbWFyZ2luLXJpZ2h0OiA4cHggIWltcG9ydGFudDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAubGVhZmxldC1jb250cm9sLWF0dHJpYnV0aW9uIHtcbiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoNjAsIDYwLCA2MCwgMC44KSAhaW1wb3J0YW50O1xuICAgICAgICAgICAgY29sb3I6ICNiZGMzYzcgIWltcG9ydGFudDtcbiAgICAgICAgICAgIGJvcmRlcjogMXB4IHNvbGlkIHJnYmEoMTIwLCAxMjAsIDEyMCwgMC4zKSAhaW1wb3J0YW50O1xuICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogNHB4ICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICBmb250LXNpemU6IDExcHggIWltcG9ydGFudDtcbiAgICAgICAgICB9XG4gICAgICAgIGA7XG4gICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgICAgfSwgMTAwKTtcblxuICAgICAgbGV0IGlzUmlnaHRDbGlja2luZyA9IGZhbHNlO1xuICAgICAgbGV0IHN0YXJ0WCwgc3RhcnRZO1xuICAgICAgXG4gICAgICBtYXAuZ2V0Q29udGFpbmVyKCkuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgaXNSaWdodENsaWNraW5nID0gdHJ1ZTtcbiAgICAgICAgc3RhcnRYID0gZS5jbGllbnRYO1xuICAgICAgICBzdGFydFkgPSBlLmNsaWVudFk7XG4gICAgICAgIFxuICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLmN1cnNvciA9ICdncmFiYmluZyc7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgbWFwLmdldENvbnRhaW5lcigpLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKGlzUmlnaHRDbGlja2luZykge1xuICAgICAgICAgIGNvbnN0IGRlbHRhWCA9IGUuY2xpZW50WCAtIHN0YXJ0WDtcbiAgICAgICAgICBjb25zdCBkZWx0YVkgPSBlLmNsaWVudFkgLSBzdGFydFk7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgYmVhcmluZ0NoYW5nZSA9IGRlbHRhWCAqIDAuNTtcbiAgICAgICAgICBjb25zdCBwaXRjaENoYW5nZSA9IGRlbHRhWSAqIDAuMTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCBjdXJyZW50QmVhcmluZyA9IG1hcC5nZXRCZWFyaW5nID8gbWFwLmdldEJlYXJpbmcoKSA6IDA7XG4gICAgICAgICAgY29uc3QgbmV3QmVhcmluZyA9IChjdXJyZW50QmVhcmluZyArIGJlYXJpbmdDaGFuZ2UpICUgMzYwO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmIChtYXAuc2V0QmVhcmluZykge1xuICAgICAgICAgICAgbWFwLnNldEJlYXJpbmcobmV3QmVhcmluZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGlmIChtYXAuc2V0UGl0Y2gpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRQaXRjaCA9IG1hcC5nZXRQaXRjaCA/IG1hcC5nZXRQaXRjaCgpIDogMDtcbiAgICAgICAgICAgIGNvbnN0IG5ld1BpdGNoID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oNjAsIGN1cnJlbnRQaXRjaCArIHBpdGNoQ2hhbmdlKSk7XG4gICAgICAgICAgICBtYXAuc2V0UGl0Y2gobmV3UGl0Y2gpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBzdGFydFggPSBlLmNsaWVudFg7XG4gICAgICAgICAgc3RhcnRZID0gZS5jbGllbnRZO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgbWFwLmdldENvbnRhaW5lcigpLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmIChpc1JpZ2h0Q2xpY2tpbmcpIHtcbiAgICAgICAgICBpc1JpZ2h0Q2xpY2tpbmcgPSBmYWxzZTtcbiAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLmN1cnNvciA9ICcnO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgbWFwLmdldENvbnRhaW5lcigpLmFkZEV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGlmIChtYXAuc2V0QmVhcmluZykge1xuICAgICAgICAgIG1hcC5zZXRCZWFyaW5nKDApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXAuc2V0UGl0Y2gpIHtcbiAgICAgICAgICBtYXAuc2V0UGl0Y2goMCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBsb2FkTWFwKCk7XG4gIH0sIFtdKTtcblxuXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zb2xlLmxvZygnRGF0YSBjaGVjazonLCB7XG4gICAgICBtYXBSZWFkeTogISFtYXBJbnN0YW5jZVJlZi5jdXJyZW50LFxuICAgICAgbG9jYXRpb25zRGF0YTogbG9jYXRpb25zRGF0YT8ubG9jYXRpb25zPy5sZW5ndGggfHwgMCxcbiAgICAgIHNlZ21lbnRzRGF0YTogc2VnbWVudHNEYXRhPy5zZWdtZW50cz8ubGVuZ3RoIHx8IDAsXG4gICAgICBsb2FkaW5nLFxuICAgICAgZXJyb3I6ICEhZXJyb3JcbiAgICB9KTtcbiAgICBcbiAgICBpZiAoIW1hcEluc3RhbmNlUmVmLmN1cnJlbnQpIHtcbiAgICAgIGNvbnNvbGUubG9nKCfinYwgTWFwIG5vdCByZWFkeSB5ZXQnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgaWYgKGxvYWRpbmcpIHtcbiAgICAgIGNvbnNvbGUubG9nKCfij7MgRGF0YSBzdGlsbCBsb2FkaW5nLi4uJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGlmIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIEdyYXBoUUwgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBpZiAoIWxvY2F0aW9uc0RhdGE/LmxvY2F0aW9ucykge1xuICAgICAgY29uc29sZS5sb2coJ+KdjCBObyBsb2NhdGlvbnMgZGF0YScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBpZiAoIXNlZ21lbnRzRGF0YT8uc2VnbWVudHMpIHtcbiAgICAgIGNvbnNvbGUubG9nKCfinYwgTm8gc2VnbWVudHMgZGF0YScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBjb25zb2xlLmxvZygn4pyFIEFsbCBkYXRhIHJlYWR5LCBwcm9jZXNzaW5nLi4uJyk7XG4gICAgY29uc29sZS5sb2coJ/Cfk40gTG9jYXRpb25zIGRhdGE6JywgbG9jYXRpb25zRGF0YS5sb2NhdGlvbnMubGVuZ3RoLCAnbG9jYXRpb25zJyk7XG4gICAgY29uc29sZS5sb2coJ/Cfm6PvuI8gU2VnbWVudHMgZGF0YTonLCBzZWdtZW50c0RhdGEuc2VnbWVudHMubGVuZ3RoLCAnc2VnbWVudHMnKTtcblxuICAgIGNvbnN0IG1hcCA9IG1hcEluc3RhbmNlUmVmLmN1cnJlbnQ7XG4gICAgY29uc3QgTCA9IHdpbmRvdy5MO1xuXG4gICAgbWFwLmVhY2hMYXllcigobGF5ZXIpID0+IHtcbiAgICAgIGlmIChsYXllci5vcHRpb25zICYmIChsYXllci5vcHRpb25zLmlzRGF0YUxheWVyIHx8IGxheWVyLm9wdGlvbnMuaXNMb2NhdGlvbkxheWVyKSkge1xuICAgICAgICBjb25zb2xlLmxvZygnUmVtb3ZpbmcgbGF5ZXI6JywgbGF5ZXIpO1xuICAgICAgICBtYXAucmVtb3ZlTGF5ZXIobGF5ZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnNvbGUubG9nKCfwn5eR77iPIENsZWFyZWQgZXhpc3RpbmcgZGF0YSBsYXllcnMnKTtcblxuICAgIGxldCBzZWdtZW50c0FkZGVkID0gMDtcbiAgICBsZXQgc2VnbWVudHNXaXRoR2VvbWV0cnkgPSAwO1xuICAgIGxldCBzZWdtZW50c1dpdGhvdXRHZW9tZXRyeSA9IDA7XG4gICAgbGV0IG9wZW5TZWdtZW50Q291bnQgPSAwO1xuICAgIGxldCBjbG9zZWRTZWdtZW50Q291bnQgPSAwO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKCfwn5uj77iPIFN0YXJ0aW5nIHRvIHByb2Nlc3Mgc2VnbWVudHM6Jywgc2VnbWVudHNEYXRhLnNlZ21lbnRzLmxlbmd0aCk7XG4gICAgXG4gICAgc2VnbWVudHNEYXRhLnNlZ21lbnRzLmZvckVhY2goKHNlZ21lbnQsIGluZGV4KSA9PiB7XG4gICAgICBpZiAoaW5kZXggPCAxMCkgeyAvLyBMb2cgZmlyc3QgMTAgZm9yIGRlYnVnZ2luZ1xuICAgICAgICBjb25zb2xlLmxvZygnUHJvY2Vzc2luZyBzZWdtZW50OicsIHNlZ21lbnQubGFuZV9pZCwgJ0RpcmVjdGlvbjonLCBzZWdtZW50LmRpcmVjdGlvbiwgJ0lzIGNsb3NlZDonLCBzZWdtZW50LmlzX2Nsb3NlZCk7XG4gICAgICAgIGlmICh0eXBlb2Ygc2VnbWVudC5nZW9tZXRyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZ2VvSnNvbiA9IEpTT04ucGFyc2Uoc2VnbWVudC5nZW9tZXRyeSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnQ29vcmRpbmF0ZXMgc2FtcGxlOicsIGdlb0pzb24uY29vcmRpbmF0ZXM/LnNsaWNlKDAsIDIpKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRmFpbGVkIHRvIHBhcnNlIGdlb21ldHJ5OicsIHNlZ21lbnQuZ2VvbWV0cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICBsZXQgY29vcmRpbmF0ZXMgPSBudWxsO1xuICAgICAgaWYgKHR5cGVvZiBzZWdtZW50Lmdlb21ldHJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGdlb0pzb24gPSBKU09OLnBhcnNlKHNlZ21lbnQuZ2VvbWV0cnkpO1xuICAgICAgICAgIGNvb3JkaW5hdGVzID0gZ2VvSnNvbi5jb29yZGluYXRlcztcbiAgICAgICAgICBzZWdtZW50c1dpdGhHZW9tZXRyeSsrO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHBhcnNlIGdlb21ldHJ5IGZvciBzZWdtZW50OicsIHNlZ21lbnQubGFuZV9pZCwgZSk7XG4gICAgICAgICAgc2VnbWVudHNXaXRob3V0R2VvbWV0cnkrKztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzZWdtZW50Lmdlb21ldHJ5ICYmIHNlZ21lbnQuZ2VvbWV0cnkuY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgY29vcmRpbmF0ZXMgPSBzZWdtZW50Lmdlb21ldHJ5LmNvb3JkaW5hdGVzO1xuICAgICAgICBzZWdtZW50c1dpdGhHZW9tZXRyeSsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VnbWVudHNXaXRob3V0R2VvbWV0cnkrKztcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKGNvb3JkaW5hdGVzICYmIEFycmF5LmlzQXJyYXkoY29vcmRpbmF0ZXMpKSB7XG4gICAgICAgIGxldCBjb2xvciwgd2VpZ2h0LCBvcGFjaXR5O1xuICAgICAgICBpZiAoc2VnbWVudC5pc19jbG9zZWQpIHtcbiAgICAgICAgICBjb2xvciA9ICcjZTc0YzNjJzsgIC8vIFJlZCBmb3IgY2xvc2VkXG4gICAgICAgICAgd2VpZ2h0ID0gMztcbiAgICAgICAgICBvcGFjaXR5ID0gMC44O1xuICAgICAgICAgIGNsb3NlZFNlZ21lbnRDb3VudCsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbG9yID0gJyMyN2FlNjAnOyAgLy8gR3JlZW4gZm9yIG9wZW5cbiAgICAgICAgICB3ZWlnaHQgPSA0O1xuICAgICAgICAgIG9wYWNpdHkgPSAwLjg7XG4gICAgICAgICAgb3BlblNlZ21lbnRDb3VudCsrO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBsZXQgbGVhZmxldENvb3JkcyA9IGNvb3JkaW5hdGVzO1xuICAgICAgICBpZiAoY29vcmRpbmF0ZXMubGVuZ3RoID4gMCAmJiBBcnJheS5pc0FycmF5KGNvb3JkaW5hdGVzWzBdKSkge1xuICAgICAgICAgIGlmIChjb29yZGluYXRlc1swXS5sZW5ndGggPT09IDIgJiYgY29vcmRpbmF0ZXNbMF1bMF0gPiBjb29yZGluYXRlc1swXVsxXSkge1xuICAgICAgICAgICAgbGVhZmxldENvb3JkcyA9IGNvb3JkaW5hdGVzLm1hcChjb29yZCA9PiBbY29vcmRbMV0sIGNvb3JkWzBdXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zdCBwb2x5bGluZSA9IEwucG9seWxpbmUobGVhZmxldENvb3Jkcywge1xuICAgICAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgICAgICB3ZWlnaHQ6IHdlaWdodCxcbiAgICAgICAgICBvcGFjaXR5OiBvcGFjaXR5LFxuICAgICAgICAgIGZpbGxPcGFjaXR5OiAwLjgsXG4gICAgICAgICAgaXNEYXRhTGF5ZXI6IHRydWVcbiAgICAgICAgfSkuYWRkVG8obWFwKTtcblxuICAgICAgICBjb25zdCBwb3B1cCA9IGBcbiAgICAgICAgICA8ZGl2IHN0eWxlPVwiZm9udC1mYW1pbHk6ICdTZWdvZSBVSScsIHNhbnMtc2VyaWY7IGZvbnQtc2l6ZTogMTNweDsgbGluZS1oZWlnaHQ6IDEuNTsgbWluLXdpZHRoOiAyMDBweDsgcGFkZGluZzogOHB4OyBcbiAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDYwLCA2MCwgNjAsIDAuOSk7IGNvbG9yOiB3aGl0ZTsgYm9yZGVyLXJhZGl1czogNnB4OyBcbiAgICAgICAgICAgICAgICAgICAgICBib3gtc2hhZG93OiAwIDRweCAxMnB4IHJnYmEoMCwwLDAsMC4zKTtcIj5cbiAgICAgICAgICAgIDxkaXYgc3R5bGU9XCJmb250LXdlaWdodDogNzAwOyBjb2xvcjogd2hpdGU7IG1hcmdpbi1ib3R0b206IDEwcHg7IGZvbnQtc2l6ZTogMTRweDsgYm9yZGVyLWJvdHRvbTogMnB4IHNvbGlkICR7Y29sb3J9OyBwYWRkaW5nLWJvdHRvbTogNnB4O1wiPlxuICAgICAgICAgICAgICAke3NlZ21lbnQubGFuZV9pZH1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBzdHlsZT1cIm1hcmdpbi1ib3R0b206IDZweDtcIj5cbiAgICAgICAgICAgICAgPHNwYW4gc3R5bGU9XCJjb2xvcjogI2VjZjBmMTsgZm9udC13ZWlnaHQ6IDUwMDtcIj5Sb2FkIElEOjwvc3Bhbj5cbiAgICAgICAgICAgICAgPHNwYW4gc3R5bGU9XCJjb2xvcjogd2hpdGU7IGZvbnQtd2VpZ2h0OiA2MDA7IG1hcmdpbi1sZWZ0OiA4cHg7XCI+JHtzZWdtZW50LnJvYWRfaWR9PC9zcGFuPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2IHN0eWxlPVwibWFyZ2luLWJvdHRvbTogNnB4O1wiPlxuICAgICAgICAgICAgICA8c3BhbiBzdHlsZT1cImNvbG9yOiAjZWNmMGYxOyBmb250LXdlaWdodDogNTAwO1wiPkxlbmd0aDo8L3NwYW4+XG4gICAgICAgICAgICAgIDxzcGFuIHN0eWxlPVwiY29sb3I6IHdoaXRlOyBmb250LXdlaWdodDogNjAwOyBtYXJnaW4tbGVmdDogOHB4O1wiPiR7c2VnbWVudC5sZW5ndGhfbT8udG9GaXhlZCgxKSB8fCAnTi9BJ31tPC9zcGFuPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2IHN0eWxlPVwibWFyZ2luLWJvdHRvbTogNnB4O1wiPlxuICAgICAgICAgICAgICA8c3BhbiBzdHlsZT1cImNvbG9yOiAjZWNmMGYxOyBmb250LXdlaWdodDogNTAwO1wiPlN0YXR1czo8L3NwYW4+XG4gICAgICAgICAgICAgIDxzcGFuIHN0eWxlPVwiY29sb3I6ICR7c2VnbWVudC5pc19jbG9zZWQgPyAnI2ZmNmI2YicgOiAnIzUxY2Y2Nid9OyBmb250LXdlaWdodDogNjAwOyBtYXJnaW4tbGVmdDogOHB4O1wiPiR7c2VnbWVudC5pc19jbG9zZWQgPyAnQ2xvc2VkJyA6ICdPcGVuJ308L3NwYW4+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgc3R5bGU9XCJjb2xvcjogI2JkYzNjNzsgZm9udC1zaXplOiAxMXB4OyBtYXJnaW4tdG9wOiA4cHg7IHBhZGRpbmctdG9wOiA2cHg7IGJvcmRlci10b3A6IDFweCBzb2xpZCAjN2Y4YzhkOyBmb250LXN0eWxlOiBpdGFsaWM7XCI+XG4gICAgICAgICAgICAgICR7c2VnbWVudC5zdGFydF9sYXRpdHVkZT8udG9GaXhlZCg2KX0sICR7c2VnbWVudC5zdGFydF9sb25naXR1ZGU/LnRvRml4ZWQoNil9IOKGkiAke3NlZ21lbnQuZW5kX2xhdGl0dWRlPy50b0ZpeGVkKDYpfSwgJHtzZWdtZW50LmVuZF9sb25naXR1ZGU/LnRvRml4ZWQoNil9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgYDtcbiAgICAgICAgcG9seWxpbmUuYmluZFBvcHVwKHBvcHVwKTtcbiAgICAgICAgc2VnbWVudHNBZGRlZCsrO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKGDwn5uj77iPIEFkZGVkICR7c2VnbWVudHNBZGRlZH0gcm9hZCBzZWdtZW50cyB0byBtYXBgKTtcbiAgICBjb25zb2xlLmxvZyhg8J+TiiBTZWdtZW50IHByb2Nlc3Npbmcgc3VtbWFyeTogJHtzZWdtZW50c1dpdGhHZW9tZXRyeX0gd2l0aCBnZW9tZXRyeSwgJHtzZWdtZW50c1dpdGhvdXRHZW9tZXRyeX0gd2l0aG91dCBnZW9tZXRyeWApO1xuXG4gICAgbGV0IGxvY2F0aW9uc0FkZGVkID0gMDtcbiAgICAvLyBHZW5lcmF0ZSByYW5kb20gY29sb3JzIGZvciBsb2NhdGlvbiB0eXBlc1xuICAgIGNvbnN0IGdlbmVyYXRlTG9jYXRpb25UeXBlQ29sb3JzID0gKGxvY2F0aW9uVHlwZXMpID0+IHtcbiAgICAgIGNvbnN0IGNvbG9yUGFsZXR0ZSA9IFtcbiAgICAgICAgJyNCQjhGQ0UnLCAnIzQ1QjdEMScsICcjMkU4NkFCJywgJyM5OEQ4QzgnLCAnI0Y3REM2RicsICcjRjhDNDcxJyxcbiAgICAgICAgJyNENEFDMEQnLCAnIzE3QTJCOCcsICcjRTc0QzNDJywgJyNFNjdFMjInLCAnIzhFNDRBRCcsICcjMTZBMDg1JyxcbiAgICAgICAgJyNGMzlDMTInLCAnI0QzNTQwMCcsICcjMjk4MEI5JywgJyNDMDM5MkInLCAnIzM0OThEQicsICcjOUI1OUI2JyxcbiAgICAgICAgJyMxQUJDOUMnLCAnIzk1QTVBNicsICcjRTkxRTYzJywgJyM5QzI3QjAnLCAnIzY3M0FCNycsICcjM0Y1MUI1JyxcbiAgICAgICAgJyMyMTk2RjMnLCAnIzAwQkNENCcsICcjMDA5Njg4JywgJyM0Q0FGNTAnLCAnIzhCQzM0QScsICcjQ0REQzM5JyxcbiAgICAgICAgJyNGRkVCM0InLCAnI0ZGQzEwNycsICcjRkY5ODAwJywgJyNGRjU3MjInLCAnIzc5NTU0OCcsICcjNjA3RDhCJ1xuICAgICAgXTtcbiAgICAgIFxuICAgICAgY29uc3QgY29sb3JzID0ge307XG4gICAgICBjb25zdCB1c2VkQ29sb3JzID0gbmV3IFNldCgpO1xuICAgICAgXG4gICAgICBsb2NhdGlvblR5cGVzLmZvckVhY2goKHR5cGUsIGluZGV4KSA9PiB7XG4gICAgICAgIC8vIFRyeSB0byBhc3NpZ24gYSBjb2xvciB0aGF0IGhhc24ndCBiZWVuIHVzZWQgeWV0XG4gICAgICAgIGxldCBjb2xvckluZGV4ID0gaW5kZXggJSBjb2xvclBhbGV0dGUubGVuZ3RoO1xuICAgICAgICBsZXQgYXR0ZW1wdHMgPSAwO1xuICAgICAgICBcbiAgICAgICAgd2hpbGUgKHVzZWRDb2xvcnMuaGFzKGNvbG9yUGFsZXR0ZVtjb2xvckluZGV4XSkgJiYgYXR0ZW1wdHMgPCBjb2xvclBhbGV0dGUubGVuZ3RoKSB7XG4gICAgICAgICAgY29sb3JJbmRleCA9IChjb2xvckluZGV4ICsgMSkgJSBjb2xvclBhbGV0dGUubGVuZ3RoO1xuICAgICAgICAgIGF0dGVtcHRzKys7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbG9yc1t0eXBlXSA9IGNvbG9yUGFsZXR0ZVtjb2xvckluZGV4XTtcbiAgICAgICAgdXNlZENvbG9ycy5hZGQoY29sb3JQYWxldHRlW2NvbG9ySW5kZXhdKTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICByZXR1cm4gY29sb3JzO1xuICAgIH07XG4gICAgXG4gICAgLy8gR2V0IHVuaXF1ZSBsb2NhdGlvbiB0eXBlcyBhbmQgZ2VuZXJhdGUgY29sb3JzXG4gICAgY29uc3QgdW5pcXVlTG9jYXRpb25UeXBlcyA9IFsuLi5uZXcgU2V0KGxvY2F0aW9uc0RhdGEubG9jYXRpb25zLm1hcChsb2MgPT4gbG9jLnVuaXRfdHlwZSkuZmlsdGVyKEJvb2xlYW4pKV07XG4gICAgY29uc3QgbG9jYXRpb25UeXBlQ29sb3JzID0gZ2VuZXJhdGVMb2NhdGlvblR5cGVDb2xvcnModW5pcXVlTG9jYXRpb25UeXBlcyk7XG4gICAgXG4gICAgY29uc29sZS5sb2coJ/Cfk40gUHJvY2Vzc2luZyBsb2NhdGlvbnMuLi4nKTtcbiAgICBsb2NhdGlvbnNEYXRhLmxvY2F0aW9ucy5mb3JFYWNoKChsb2NhdGlvbiwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChpbmRleCA8IDUpIHsgLy8gTG9nIGZpcnN0IDUgbG9jYXRpb25zIGZvciBkZWJ1Z2dpbmdcbiAgICAgICAgY29uc29sZS5sb2coJ0xvY2F0aW9uOicsIGxvY2F0aW9uLmxvY2F0aW9uX25hbWUsICdDb29yZHM6JywgbG9jYXRpb24ubGF0aXR1ZGUsIGxvY2F0aW9uLmxvbmdpdHVkZSwgJ1R5cGU6JywgbG9jYXRpb24udW5pdF90eXBlKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKGxvY2F0aW9uLmxhdGl0dWRlICYmIGxvY2F0aW9uLmxvbmdpdHVkZSkge1xuICAgICAgICBjb25zdCBtYXJrZXJDb2xvciA9IGxvY2F0aW9uVHlwZUNvbG9yc1tsb2NhdGlvbi51bml0X3R5cGVdIHx8ICcjOTVhNWE2JztcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IG1hcmtlciA9IEwuY2lyY2xlTWFya2VyKFtsb2NhdGlvbi5sYXRpdHVkZSwgbG9jYXRpb24ubG9uZ2l0dWRlXSwge1xuICAgICAgICAgIHJhZGl1czogNCxcbiAgICAgICAgICBmaWxsQ29sb3I6IG1hcmtlckNvbG9yLFxuICAgICAgICAgIGNvbG9yOiAnI2ZmZicsXG4gICAgICAgICAgd2VpZ2h0OiAxLFxuICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgZmlsbE9wYWNpdHk6IDAuOCxcbiAgICAgICAgICBpc0xvY2F0aW9uTGF5ZXI6IHRydWVcbiAgICAgICAgfSkuYWRkVG8obWFwKTtcblxuICAgICAgICBjb25zdCBwb3B1cCA9IGBcbiAgICAgICAgICA8ZGl2IHN0eWxlPVwiZm9udC1mYW1pbHk6ICdTZWdvZSBVSScsIHNhbnMtc2VyaWY7IGZvbnQtc2l6ZTogMTNweDsgbGluZS1oZWlnaHQ6IDEuNTsgbWluLXdpZHRoOiAyMDBweDsgcGFkZGluZzogOHB4OyBcbiAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDYwLCA2MCwgNjAsIDAuOSk7IGNvbG9yOiB3aGl0ZTsgYm9yZGVyLXJhZGl1czogNnB4OyBcbiAgICAgICAgICAgICAgICAgICAgICBib3gtc2hhZG93OiAwIDRweCAxMnB4IHJnYmEoMCwwLDAsMC4zKTtcIj5cbiAgICAgICAgICAgIDxkaXYgc3R5bGU9XCJmb250LXdlaWdodDogNzAwOyBjb2xvcjogd2hpdGU7IG1hcmdpbi1ib3R0b206IDEwcHg7IGZvbnQtc2l6ZTogMTRweDsgYm9yZGVyLWJvdHRvbTogMnB4IHNvbGlkICR7bWFya2VyQ29sb3J9OyBwYWRkaW5nLWJvdHRvbTogNnB4O1wiPlxuICAgICAgICAgICAgICAke2xvY2F0aW9uLmxvY2F0aW9uX25hbWV9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgc3R5bGU9XCJtYXJnaW4tYm90dG9tOiA2cHg7XCI+XG4gICAgICAgICAgICAgIDxzcGFuIHN0eWxlPVwiY29sb3I6ICNlY2YwZjE7IGZvbnQtd2VpZ2h0OiA1MDA7XCI+VHlwZTo8L3NwYW4+XG4gICAgICAgICAgICAgIDxzcGFuIHN0eWxlPVwiY29sb3I6IHdoaXRlOyBmb250LXdlaWdodDogNjAwOyBtYXJnaW4tbGVmdDogOHB4O1wiPiR7bG9jYXRpb24udW5pdF90eXBlIHx8ICdVbmtub3duJ308L3NwYW4+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgc3R5bGU9XCJtYXJnaW4tYm90dG9tOiA2cHg7XCI+XG4gICAgICAgICAgICAgIDxzcGFuIHN0eWxlPVwiY29sb3I6ICNlY2YwZjE7IGZvbnQtd2VpZ2h0OiA1MDA7XCI+Q2F0ZWdvcnk6PC9zcGFuPlxuICAgICAgICAgICAgICA8c3BhbiBzdHlsZT1cImNvbG9yOiB3aGl0ZTsgZm9udC13ZWlnaHQ6IDYwMDsgbWFyZ2luLWxlZnQ6IDhweDtcIj4ke2xvY2F0aW9uLmxvY2F0aW9uX2NhdGVnb3J5fTwvc3Bhbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgJHtsb2NhdGlvbi5lbGV2YXRpb25fbSA/IGBcbiAgICAgICAgICAgIDxkaXYgc3R5bGU9XCJtYXJnaW4tYm90dG9tOiA2cHg7XCI+XG4gICAgICAgICAgICAgIDxzcGFuIHN0eWxlPVwiY29sb3I6ICNlY2YwZjE7IGZvbnQtd2VpZ2h0OiA1MDA7XCI+RWxldmF0aW9uOjwvc3Bhbj5cbiAgICAgICAgICAgICAgPHNwYW4gc3R5bGU9XCJjb2xvcjogd2hpdGU7IGZvbnQtd2VpZ2h0OiA2MDA7IG1hcmdpbi1sZWZ0OiA4cHg7XCI+JHtsb2NhdGlvbi5lbGV2YXRpb25fbS50b0ZpeGVkKDEpfW08L3NwYW4+XG4gICAgICAgICAgICA8L2Rpdj5gIDogJyd9XG4gICAgICAgICAgICAke2xvY2F0aW9uLnBpdF9uYW1lID8gYFxuICAgICAgICAgICAgPGRpdiBzdHlsZT1cIm1hcmdpbi1ib3R0b206IDZweDtcIj5cbiAgICAgICAgICAgICAgPHNwYW4gc3R5bGU9XCJjb2xvcjogI2VjZjBmMTsgZm9udC13ZWlnaHQ6IDUwMDtcIj5QaXQ6PC9zcGFuPlxuICAgICAgICAgICAgICA8c3BhbiBzdHlsZT1cImNvbG9yOiB3aGl0ZTsgZm9udC13ZWlnaHQ6IDYwMDsgbWFyZ2luLWxlZnQ6IDhweDtcIj4ke2xvY2F0aW9uLnBpdF9uYW1lfTwvc3Bhbj5cbiAgICAgICAgICAgIDwvZGl2PmAgOiAnJ31cbiAgICAgICAgICAgICR7bG9jYXRpb24ucmVnaW9uX25hbWUgPyBgXG4gICAgICAgICAgICA8ZGl2IHN0eWxlPVwibWFyZ2luLWJvdHRvbTogNnB4O1wiPlxuICAgICAgICAgICAgICA8c3BhbiBzdHlsZT1cImNvbG9yOiAjZWNmMGYxOyBmb250LXdlaWdodDogNTAwO1wiPlJlZ2lvbjo8L3NwYW4+XG4gICAgICAgICAgICAgIDxzcGFuIHN0eWxlPVwiY29sb3I6IHdoaXRlOyBmb250LXdlaWdodDogNjAwOyBtYXJnaW4tbGVmdDogOHB4O1wiPiR7bG9jYXRpb24ucmVnaW9uX25hbWV9PC9zcGFuPlxuICAgICAgICAgICAgPC9kaXY+YCA6ICcnfVxuICAgICAgICAgICAgPGRpdiBzdHlsZT1cImNvbG9yOiAjYmRjM2M3OyBmb250LXNpemU6IDExcHg7IG1hcmdpbi10b3A6IDhweDsgcGFkZGluZy10b3A6IDZweDsgYm9yZGVyLXRvcDogMXB4IHNvbGlkICM3ZjhjOGQ7IGZvbnQtc3R5bGU6IGl0YWxpYztcIj5cbiAgICAgICAgICAgICAgJHtsb2NhdGlvbi5sYXRpdHVkZS50b0ZpeGVkKDYpfSwgJHtsb2NhdGlvbi5sb25naXR1ZGUudG9GaXhlZCg2KX1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICBgO1xuICAgICAgICBtYXJrZXIuYmluZFBvcHVwKHBvcHVwKTtcbiAgICAgICAgbG9jYXRpb25zQWRkZWQrKztcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBjb25zb2xlLmxvZyhg8J+TjSBBZGRlZCAke2xvY2F0aW9uc0FkZGVkfSBsb2NhdGlvbiBtYXJrZXJzIHRvIG1hcGApO1xuICAgIFxuICAgIGlmIChsb2NhdGlvbnNBZGRlZCA+IDAgfHwgc2VnbWVudHNBZGRlZCA+IDApIHtcbiAgICAgIGNvbnN0IGFsbExhdExuZ3MgPSBbXTtcbiAgICAgIFxuICAgICAgbG9jYXRpb25zRGF0YS5sb2NhdGlvbnMuZm9yRWFjaCgobG9jYXRpb24pID0+IHtcbiAgICAgICAgaWYgKGxvY2F0aW9uLmxhdGl0dWRlICYmIGxvY2F0aW9uLmxvbmdpdHVkZSkge1xuICAgICAgICAgIGFsbExhdExuZ3MucHVzaChbbG9jYXRpb24ubGF0aXR1ZGUsIGxvY2F0aW9uLmxvbmdpdHVkZV0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgc2VnbWVudHNEYXRhLnNlZ21lbnRzLmZvckVhY2goKHNlZ21lbnQpID0+IHtcbiAgICAgICAgaWYgKHNlZ21lbnQuZ2VvbWV0cnkpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZ2VvSnNvbiA9IEpTT04ucGFyc2Uoc2VnbWVudC5nZW9tZXRyeSk7XG4gICAgICAgICAgICBpZiAoZ2VvSnNvbi5jb29yZGluYXRlcyAmJiBBcnJheS5pc0FycmF5KGdlb0pzb24uY29vcmRpbmF0ZXMpKSB7XG4gICAgICAgICAgICAgIGdlb0pzb24uY29vcmRpbmF0ZXMuZm9yRWFjaChjb29yZCA9PiB7XG4gICAgICAgICAgICAgICAgYWxsTGF0TG5ncy5wdXNoKFtjb29yZFsxXSwgY29vcmRbMF1dKTsgXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIFNraXAgaW52YWxpZCBnZW9tZXRyeVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGlmIChhbGxMYXRMbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgYm91bmRzID0gTC5sYXRMbmdCb3VuZHMoYWxsTGF0TG5ncyk7XG4gICAgICAgIFxuICAgICAgICBtYXAuZml0Qm91bmRzKGJvdW5kcywgeyBcbiAgICAgICAgICBwYWRkaW5nOiBbNTAsIDUwXSxcbiAgICAgICAgICBtYXhab29tOiAxNiBcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBjZW50ZXIgPSBib3VuZHMuZ2V0Q2VudGVyKCk7XG4gICAgICAgIGNvbnN0IHpvb20gPSBtYXAuZ2V0Wm9vbSgpO1xuICAgICAgICBjb25zb2xlLmxvZyhg8J+Xuu+4jyBNYXAgY2VudGVyZWQgYXQ6ICR7Y2VudGVyLmxhdC50b0ZpeGVkKDYpfSwgJHtjZW50ZXIubG5nLnRvRml4ZWQoNil9IHdpdGggem9vbTogJHt6b29tfWApO1xuICAgICAgICBjb25zb2xlLmxvZyhg8J+TiiBGaXR0ZWQgYm91bmRzIHRvICR7YWxsTGF0TG5ncy5sZW5ndGh9IGRhdGEgcG9pbnRzYCk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKCfwn46oIENyZWF0aW5nIGxlZ2VuZC4uLicpO1xuICAgIGFkZFNpbXBsZUxlZ2VuZChsb2NhdGlvbnNEYXRhLmxvY2F0aW9ucy5sZW5ndGgsIHNlZ21lbnRzQWRkZWQpO1xuICAgIGNvbnNvbGUubG9nKCfwn46oIExlZ2VuZCBjcmVhdGlvbiBjb21wbGV0ZWQnKTtcblxuICB9LCBbbG9jYXRpb25zRGF0YSwgc2VnbWVudHNEYXRhLCBsb2FkaW5nLCBlcnJvcl0pO1xuICBcbiAgY29uc3QgYWRkU2ltcGxlTGVnZW5kID0gKGxvY2F0aW9uQ291bnQsIHNlZ21lbnRDb3VudCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKCfwn46oIGFkZFNpbXBsZUxlZ2VuZCBjYWxsZWQgd2l0aDonLCB7IGxvY2F0aW9uQ291bnQsIHNlZ21lbnRDb3VudCB9KTtcbiAgICBcbiAgICBjb25zdCBleGlzdGluZ0xlZ2VuZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzaW1wbGUtbGVnZW5kJyk7XG4gICAgaWYgKGV4aXN0aW5nTGVnZW5kKSB7XG4gICAgICBjb25zb2xlLmxvZygn8J+OqCBSZW1vdmluZyBleGlzdGluZyBsZWdlbmQnKTtcbiAgICAgIGV4aXN0aW5nTGVnZW5kLnJlbW92ZSgpO1xuICAgIH1cbiAgICBcbiAgICBsZXQgb3BlblJvYWRzID0gMDtcbiAgICBsZXQgY2xvc2VkUm9hZHMgPSAwO1xuICAgIGlmIChzZWdtZW50c0RhdGE/LnNlZ21lbnRzKSB7XG4gICAgICBzZWdtZW50c0RhdGEuc2VnbWVudHMuZm9yRWFjaChzZWdtZW50ID0+IHtcbiAgICAgICAgaWYgKHNlZ21lbnQuaXNfY2xvc2VkKSB7XG4gICAgICAgICAgY2xvc2VkUm9hZHMrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcGVuUm9hZHMrKztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGxvY2F0aW9uVHlwZXMgPSB7fTtcbiAgICBpZiAobG9jYXRpb25zRGF0YT8ubG9jYXRpb25zKSB7XG4gICAgICBsb2NhdGlvbnNEYXRhLmxvY2F0aW9ucy5mb3JFYWNoKGxvY2F0aW9uID0+IHtcbiAgICAgICAgY29uc3QgdHlwZSA9IGxvY2F0aW9uLnVuaXRfdHlwZSB8fCAnVW5rbm93bic7XG4gICAgICAgIGxvY2F0aW9uVHlwZXNbdHlwZV0gPSAobG9jYXRpb25UeXBlc1t0eXBlXSB8fCAwKSArIDE7XG4gICAgICB9KTtcbiAgICB9XG4gICAgXG4gICAgLy8gR2VuZXJhdGUgY29sb3JzIGZvciBsZWdlbmQgdXNpbmcgdGhlIHNhbWUgZnVuY3Rpb25cbiAgICBjb25zdCBnZW5lcmF0ZUxlZ2VuZENvbG9ycyA9IChsb2NhdGlvblR5cGVzKSA9PiB7XG4gICAgICBjb25zdCBjb2xvclBhbGV0dGUgPSBbXG4gICAgICAgICcjQkI4RkNFJywgJyM0NUI3RDEnLCAnIzJFODZBQicsICcjOThEOEM4JywgJyNGN0RDNkYnLCAnI0Y4QzQ3MScsXG4gICAgICAgICcjRDRBQzBEJywgJyMxN0EyQjgnLCAnI0U3NEMzQycsICcjRTY3RTIyJywgJyM4RTQ0QUQnLCAnIzE2QTA4NScsXG4gICAgICAgICcjRjM5QzEyJywgJyNEMzU0MDAnLCAnIzI5ODBCOScsICcjQzAzOTJCJywgJyMzNDk4REInLCAnIzlCNTlCNicsXG4gICAgICAgICcjMUFCQzlDJywgJyM5NUE1QTYnLCAnI0U5MUU2MycsICcjOUMyN0IwJywgJyM2NzNBQjcnLCAnIzNGNTFCNScsXG4gICAgICAgICcjMjE5NkYzJywgJyMwMEJDRDQnLCAnIzAwOTY4OCcsICcjNENBRjUwJywgJyM4QkMzNEEnLCAnI0NEREMzOScsXG4gICAgICAgICcjRkZFQjNCJywgJyNGRkMxMDcnLCAnI0ZGOTgwMCcsICcjRkY1NzIyJywgJyM3OTU1NDgnLCAnIzYwN0Q4QidcbiAgICAgIF07XG4gICAgICBcbiAgICAgIGNvbnN0IGNvbG9ycyA9IHt9O1xuICAgICAgY29uc3QgdXNlZENvbG9ycyA9IG5ldyBTZXQoKTtcbiAgICAgIFxuICAgICAgbG9jYXRpb25UeXBlcy5mb3JFYWNoKCh0eXBlLCBpbmRleCkgPT4ge1xuICAgICAgICBsZXQgY29sb3JJbmRleCA9IGluZGV4ICUgY29sb3JQYWxldHRlLmxlbmd0aDtcbiAgICAgICAgbGV0IGF0dGVtcHRzID0gMDtcbiAgICAgICAgXG4gICAgICAgIHdoaWxlICh1c2VkQ29sb3JzLmhhcyhjb2xvclBhbGV0dGVbY29sb3JJbmRleF0pICYmIGF0dGVtcHRzIDwgY29sb3JQYWxldHRlLmxlbmd0aCkge1xuICAgICAgICAgIGNvbG9ySW5kZXggPSAoY29sb3JJbmRleCArIDEpICUgY29sb3JQYWxldHRlLmxlbmd0aDtcbiAgICAgICAgICBhdHRlbXB0cysrO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb2xvcnNbdHlwZV0gPSBjb2xvclBhbGV0dGVbY29sb3JJbmRleF07XG4gICAgICAgIHVzZWRDb2xvcnMuYWRkKGNvbG9yUGFsZXR0ZVtjb2xvckluZGV4XSk7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgcmV0dXJuIGNvbG9ycztcbiAgICB9O1xuICAgIFxuICAgIGNvbnN0IGxvY2F0aW9uVHlwZUNvbG9ycyA9IGdlbmVyYXRlTGVnZW5kQ29sb3JzKE9iamVjdC5rZXlzKGxvY2F0aW9uVHlwZXMpKTtcbiAgICBcbiAgICBjb25zdCBsZWdlbmRIdG1sID0gYFxuICAgICAgPGRpdiBpZD1cInNpbXBsZS1sZWdlbmRcIiBzdHlsZT1cInBvc2l0aW9uOiBmaXhlZDsgdG9wOiAyMHB4OyByaWdodDogMjBweDsgXG4gICAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoNjAsIDYwLCA2MCwgMC43KTsgY29sb3I6IHdoaXRlOyBcbiAgICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogOHB4OyBmb250LWZhbWlseTogJ1NlZ29lIFVJJywgc2Fucy1zZXJpZjtcbiAgICAgICAgICAgICAgYm94LXNoYWRvdzogMCA0cHggMjBweCByZ2JhKDAsMCwwLDAuNik7IHotaW5kZXg6IDEwMDA7IFxuICAgICAgICAgICAgICBtaW4td2lkdGg6IDI4MHB4OyBtYXgtaGVpZ2h0OiA0MDBweDsgb3ZlcmZsb3cteTogYXV0bztcbiAgICAgICAgICAgICAgYmFja2Ryb3AtZmlsdGVyOiBibHVyKDEwcHgpOyBjdXJzb3I6IG1vdmU7XCI+XG4gICAgICAgIFxuICAgICAgICA8ZGl2IGlkPVwibGVnZW5kLWhlYWRlclwiIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjogcmdiYSg0MCwgNDAsIDQwLCAwLjkpOyBwYWRkaW5nOiAxMnB4IDE2cHg7IFxuICAgICAgICAgICAgICAgICAgICBib3JkZXItcmFkaXVzOiA4cHggOHB4IDAgMDsgZGlzcGxheTogZmxleDsgYWxpZ24taXRlbXM6IGNlbnRlcjsganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuOyBjdXJzb3I6IG1vdmU7XCJcbiAgICAgICAgICAgICBvbmNsaWNrPVwidG9nZ2xlTGVnZW5kKClcIj5cbiAgICAgICAgICA8ZGl2IHN0eWxlPVwiZGlzcGxheTogZmxleDsgYWxpZ24taXRlbXM6IGNlbnRlcjtcIj5cbiAgICAgICAgICAgIDxkaXYgc3R5bGU9XCJ3aWR0aDogMjBweDsgaGVpZ2h0OiAyMHB4OyBiYWNrZ3JvdW5kLWNvbG9yOiAjMzQ5OGRiOyBib3JkZXItcmFkaXVzOiA0cHg7IFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luLXJpZ2h0OiAxMHB4OyBkaXNwbGF5OiBmbGV4OyBhbGlnbi1pdGVtczogY2VudGVyOyBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcIj5cbiAgICAgICAgICAgICAgPHNwYW4gc3R5bGU9XCJjb2xvcjogd2hpdGU7IGZvbnQtc2l6ZTogMTJweDsgZm9udC13ZWlnaHQ6IGJvbGQ7XCI+4puPPC9zcGFuPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8c3BhbiBzdHlsZT1cImNvbG9yOiB3aGl0ZTsgZm9udC13ZWlnaHQ6IDYwMDsgZm9udC1zaXplOiAxNHB4O1wiPk1pbmUgTWFwPC9zcGFuPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgaWQ9XCJsZWdlbmQtdG9nZ2xlLWFycm93XCIgc3R5bGU9XCJjb2xvcjogd2hpdGU7IGZvbnQtc2l6ZTogMTZweDsgY3Vyc29yOiBwb2ludGVyO1wiPuKWvDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgXG4gICAgICAgIDxkaXYgaWQ9XCJsZWdlbmQtY29udGVudFwiIHN0eWxlPVwicGFkZGluZzogMDsgY29sb3I6IHdoaXRlOyBmb250LXNpemU6IDEycHg7XCI+XG4gICAgICAgICAgXG4gICAgICAgICAgPGRpdiBzdHlsZT1cImJvcmRlci1sZWZ0OiAzcHggc29saWQgIzM0OThkYjsgbWFyZ2luOiA4cHggMDtcIj5cbiAgICAgICAgICAgIDxkaXYgaWQ9XCJyb2FkLWxheWVycy1oZWFkZXJcIiBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6IHJnYmEoNTIsIDE1MiwgMjE5LCAwLjEpOyBwYWRkaW5nOiA4cHggMTJweDsgY3Vyc29yOiBwb2ludGVyOyBcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7IGFsaWduLWl0ZW1zOiBjZW50ZXI7IGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcIlxuICAgICAgICAgICAgICAgICBvbmNsaWNrPVwidG9nZ2xlU2VjdGlvbigncm9hZC1sYXllcnMtY29udGVudCcsICdyb2FkLWxheWVycy1hcnJvdycpXCI+XG4gICAgICAgICAgICAgIDxkaXYgc3R5bGU9XCJkaXNwbGF5OiBmbGV4OyBhbGlnbi1pdGVtczogY2VudGVyO1wiPlxuICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9XCJ3aWR0aDogMTZweDsgaGVpZ2h0OiAxNnB4OyBiYWNrZ3JvdW5kLWNvbG9yOiAjMzQ5OGRiOyBib3JkZXItcmFkaXVzOiAzcHg7IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbi1yaWdodDogOHB4OyBkaXNwbGF5OiBmbGV4OyBhbGlnbi1pdGVtczogY2VudGVyOyBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcIj5cbiAgICAgICAgICAgICAgICAgIDxzcGFuIHN0eWxlPVwiY29sb3I6IHdoaXRlOyBmb250LXNpemU6IDEwcHg7XCI+8J+bozwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8c3BhbiBzdHlsZT1cImNvbG9yOiAjMzQ5OGRiOyBmb250LXdlaWdodDogNjAwOyBmb250LXNpemU6IDEzcHg7XCI+Um9hZCBMYXllcnM8L3NwYW4+XG4gICAgICAgICAgICAgICAgPGRpdiBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6ICMzNDk4ZGI7IGNvbG9yOiB3aGl0ZTsgYm9yZGVyLXJhZGl1czogMTBweDsgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogMnB4IDhweDsgbWFyZ2luLWxlZnQ6IDhweDsgZm9udC1zaXplOiAxMHB4O1wiPjI8L2Rpdj5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDxkaXYgaWQ9XCJyb2FkLWxheWVycy1hcnJvd1wiIHN0eWxlPVwiY29sb3I6ICMzNDk4ZGI7IGZvbnQtc2l6ZTogMTRweDtcIj7ilrw8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBpZD1cInJvYWQtbGF5ZXJzLWNvbnRlbnRcIiBzdHlsZT1cInBhZGRpbmc6IDhweCAxMnB4IDhweCAzMnB4O1wiPlxuICAgICAgICAgICAgICA8ZGl2IHN0eWxlPVwiZGlzcGxheTogZmxleDsgYWxpZ24taXRlbXM6IGNlbnRlcjsgbWFyZ2luLWJvdHRvbTogNnB4O1wiPlxuICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9XCJ3aWR0aDogMTJweDsgaGVpZ2h0OiAzcHg7IGJhY2tncm91bmQtY29sb3I6ICMyN2FlNjA7IG1hcmdpbi1yaWdodDogMTBweDsgYm9yZGVyLXJhZGl1czogMnB4O1wiPjwvZGl2PlxuICAgICAgICAgICAgICAgIDxzcGFuIHN0eWxlPVwiY29sb3I6ICNiZGMzYzc7XCI+T3BlbiBSb2FkcyAoJHtvcGVuUm9hZHN9KTwvc3Bhbj5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDxkaXYgc3R5bGU9XCJkaXNwbGF5OiBmbGV4OyBhbGlnbi1pdGVtczogY2VudGVyOyBtYXJnaW4tYm90dG9tOiA2cHg7XCI+XG4gICAgICAgICAgICAgICAgPGRpdiBzdHlsZT1cIndpZHRoOiAxMnB4OyBoZWlnaHQ6IDNweDsgYmFja2dyb3VuZC1jb2xvcjogI2U3NGMzYzsgbWFyZ2luLXJpZ2h0OiAxMHB4OyBib3JkZXItcmFkaXVzOiAycHg7XCI+PC9kaXY+XG4gICAgICAgICAgICAgICAgPHNwYW4gc3R5bGU9XCJjb2xvcjogI2JkYzNjNztcIj5DbG9zZWQgUm9hZHMgKCR7Y2xvc2VkUm9hZHN9KTwvc3Bhbj5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICBcbiAgICAgICAgICA8ZGl2IHN0eWxlPVwiYm9yZGVyLWxlZnQ6IDNweCBzb2xpZCAjZTc0YzNjOyBtYXJnaW46IDhweCAwO1wiPlxuICAgICAgICAgICAgPGRpdiBpZD1cImxvY2F0aW9uLXR5cGVzLWhlYWRlclwiIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyMzEsIDc2LCA2MCwgMC4xKTsgcGFkZGluZzogOHB4IDEycHg7IGN1cnNvcjogcG9pbnRlcjsgXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiBmbGV4OyBhbGlnbi1pdGVtczogY2VudGVyOyBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XCJcbiAgICAgICAgICAgICAgICAgb25jbGljaz1cInRvZ2dsZVNlY3Rpb24oJ2xvY2F0aW9uLXR5cGVzLWNvbnRlbnQnLCAnbG9jYXRpb24tdHlwZXMtYXJyb3cnKVwiPlxuICAgICAgICAgICAgICA8ZGl2IHN0eWxlPVwiZGlzcGxheTogZmxleDsgYWxpZ24taXRlbXM6IGNlbnRlcjtcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPVwid2lkdGg6IDE2cHg7IGhlaWdodDogMTZweDsgYmFja2dyb3VuZC1jb2xvcjogI2U3NGMzYzsgYm9yZGVyLXJhZGl1czogM3B4OyBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW4tcmlnaHQ6IDhweDsgZGlzcGxheTogZmxleDsgYWxpZ24taXRlbXM6IGNlbnRlcjsganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XCI+XG4gICAgICAgICAgICAgICAgICA8c3BhbiBzdHlsZT1cImNvbG9yOiB3aGl0ZTsgZm9udC1zaXplOiAxMHB4O1wiPvCfk408L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPHNwYW4gc3R5bGU9XCJjb2xvcjogI2U3NGMzYzsgZm9udC13ZWlnaHQ6IDYwMDsgZm9udC1zaXplOiAxM3B4O1wiPkxvY2F0aW9uIFR5cGVzPC9zcGFuPlxuICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOiAjZTc0YzNjOyBjb2xvcjogd2hpdGU7IGJvcmRlci1yYWRpdXM6IDEwcHg7IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IDJweCA4cHg7IG1hcmdpbi1sZWZ0OiA4cHg7IGZvbnQtc2l6ZTogMTBweDtcIj4ke09iamVjdC5rZXlzKGxvY2F0aW9uVHlwZXMpLmxlbmd0aH08L2Rpdj5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDxkaXYgaWQ9XCJsb2NhdGlvbi10eXBlcy1hcnJvd1wiIHN0eWxlPVwiY29sb3I6ICNlNzRjM2M7IGZvbnQtc2l6ZTogMTRweDtcIj7ilrw8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBpZD1cImxvY2F0aW9uLXR5cGVzLWNvbnRlbnRcIiBzdHlsZT1cInBhZGRpbmc6IDhweCAxMnB4IDhweCAzMnB4O1wiPlxuICAgICAgICAgICAgICAke09iamVjdC5lbnRyaWVzKGxvY2F0aW9uVHlwZXMpLnNvcnQoKGEsIGIpID0+IGJbMV0gLSBhWzFdKS5tYXAoKFt0eXBlLCBjb3VudF0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xvciA9IGxvY2F0aW9uVHlwZUNvbG9yc1t0eXBlXSB8fCAnIzk1YTVhNic7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPVwiZGlzcGxheTogZmxleDsgYWxpZ24taXRlbXM6IGNlbnRlcjsgbWFyZ2luLWJvdHRvbTogNnB4O1wiPlxuICAgICAgICAgICAgICAgICAgPGRpdiBzdHlsZT1cIndpZHRoOiA4cHg7IGhlaWdodDogOHB4OyBiYWNrZ3JvdW5kLWNvbG9yOiAke2NvbG9yfTsgbWFyZ2luLXJpZ2h0OiAxMHB4OyBib3JkZXItcmFkaXVzOiA1MCU7XCI+PC9kaXY+XG4gICAgICAgICAgICAgICAgICA8c3BhbiBzdHlsZT1cImNvbG9yOiAjYmRjM2M3O1wiPiR7dHlwZX0gKCR7Y291bnR9KTwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5gO1xuICAgICAgICAgICAgICB9KS5qb2luKCcnKX1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIFxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIGA7XG4gICAgXG4gICAgY29uc3QgbGVnZW5kRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGxlZ2VuZEVsZW1lbnQuaW5uZXJIVE1MID0gbGVnZW5kSHRtbDtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGxlZ2VuZEVsZW1lbnQpO1xuICAgIFxuICAgIHdpbmRvdy50b2dnbGVTZWN0aW9uID0gZnVuY3Rpb24oY29udGVudElkLCBhcnJvd0lkKSB7XG4gICAgICBjb25zdCBjb250ZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY29udGVudElkKTtcbiAgICAgIGNvbnN0IGFycm93ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYXJyb3dJZCk7XG4gICAgICBcbiAgICAgIGlmIChjb250ZW50LnN0eWxlLmRpc3BsYXkgPT09ICdub25lJykge1xuICAgICAgICBjb250ZW50LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICBhcnJvdy50ZXh0Q29udGVudCA9ICfilrwnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICBhcnJvdy50ZXh0Q29udGVudCA9ICfilrYnO1xuICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgd2luZG93LnRvZ2dsZUxlZ2VuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgY29udGVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsZWdlbmQtY29udGVudCcpO1xuICAgICAgY29uc3QgYXJyb3cgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbGVnZW5kLXRvZ2dsZS1hcnJvdycpO1xuICAgICAgXG4gICAgICBpZiAoY29udGVudC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScpIHtcbiAgICAgICAgY29udGVudC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgYXJyb3cudGV4dENvbnRlbnQgPSAn4pa8JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRlbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgYXJyb3cudGV4dENvbnRlbnQgPSAn4pa2JztcbiAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIGxldCBpc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgbGV0IGN1cnJlbnRYO1xuICAgIGxldCBjdXJyZW50WTtcbiAgICBsZXQgaW5pdGlhbFg7XG4gICAgbGV0IGluaXRpYWxZO1xuICAgIGxldCB4T2Zmc2V0ID0gMDtcbiAgICBsZXQgeU9mZnNldCA9IDA7XG4gICAgXG4gICAgY29uc3QgbGVnZW5kID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NpbXBsZS1sZWdlbmQnKTtcbiAgICBjb25zdCBoZWFkZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbGVnZW5kLWhlYWRlcicpO1xuICAgIFxuICAgIGhlYWRlci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBkcmFnU3RhcnQpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGRyYWcpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBkcmFnRW5kKTtcbiAgICBcbiAgICBmdW5jdGlvbiBkcmFnU3RhcnQoZSkge1xuICAgICAgaWYgKGUudGFyZ2V0LmlkID09PSAnbGVnZW5kLXRvZ2dsZS1hcnJvdycpIHJldHVybjtcbiAgICAgIFxuICAgICAgaW5pdGlhbFggPSBlLmNsaWVudFggLSB4T2Zmc2V0O1xuICAgICAgaW5pdGlhbFkgPSBlLmNsaWVudFkgLSB5T2Zmc2V0O1xuICAgICAgXG4gICAgICBpZiAoZS50YXJnZXQgPT09IGhlYWRlciB8fCBoZWFkZXIuY29udGFpbnMoZS50YXJnZXQpKSB7XG4gICAgICAgIGlzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBmdW5jdGlvbiBkcmFnKGUpIHtcbiAgICAgIGlmIChpc0RyYWdnaW5nKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgY3VycmVudFggPSBlLmNsaWVudFggLSBpbml0aWFsWDtcbiAgICAgICAgY3VycmVudFkgPSBlLmNsaWVudFkgLSBpbml0aWFsWTtcbiAgICAgICAgXG4gICAgICAgIHhPZmZzZXQgPSBjdXJyZW50WDtcbiAgICAgICAgeU9mZnNldCA9IGN1cnJlbnRZO1xuICAgICAgICBcbiAgICAgICAgbGVnZW5kLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgke2N1cnJlbnRYfXB4LCAke2N1cnJlbnRZfXB4LCAwKWA7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIGRyYWdFbmQoZSkge1xuICAgICAgaW5pdGlhbFggPSBjdXJyZW50WDtcbiAgICAgIGluaXRpYWxZID0gY3VycmVudFk7XG4gICAgICBpc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKCfwn46oIExlZ2VuZCBlbGVtZW50IGFkZGVkIHRvIERPTSB3aXRoIGNvbGxhcHNpYmxlIGZ1bmN0aW9uYWxpdHknKTtcbiAgfTtcblxuICBpZiAoZXJyb3IpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBzdHlsZT17e1xuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgdG9wOiAnNTAlJyxcbiAgICAgICAgbGVmdDogJzUwJScsXG4gICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgtNTAlLCAtNTAlKScsXG4gICAgICAgIHpJbmRleDogMTAwMCxcbiAgICAgICAgYmFja2dyb3VuZDogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC45KScsXG4gICAgICAgIHBhZGRpbmc6ICcyMHB4JyxcbiAgICAgICAgYm9yZGVyUmFkaXVzOiAnOHB4JyxcbiAgICAgICAgYm94U2hhZG93OiAnMCA0cHggMjBweCByZ2JhKDAsMCwwLDAuMyknLFxuICAgICAgICBjb2xvcjogJ3JlZCdcbiAgICAgIH19PlxuICAgICAgICA8aDM+RXJyb3IgTG9hZGluZyBNYXAgRGF0YTwvaDM+XG4gICAgICAgIDxwPkVycm9yOiB7ZXJyb3J9PC9wPlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuICBcbiAgY29uc29sZS5sb2coJ1JlbmRlciBjaGVjazonLCB7XG4gICAgbG9jYXRpb25zRGF0YTogbG9jYXRpb25zRGF0YT8ubG9jYXRpb25zPy5sZW5ndGggfHwgMCxcbiAgICBzZWdtZW50c0RhdGE6IHNlZ21lbnRzRGF0YT8uc2VnbWVudHM/Lmxlbmd0aCB8fCAwLFxuICAgIGxvYWRpbmcsXG4gICAgZXJyb3I6ICEhZXJyb3JcbiAgfSk7XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IHN0eWxlPXt7IHBvc2l0aW9uOiAncmVsYXRpdmUnLCB3aWR0aDogJzEwMCUnLCBoZWlnaHQ6ICcxMDB2aCcgfX0+XG4gICAgICA8ZGl2IFxuICAgICAgICBjbGFzc05hbWU9XCJmb2xpdW0tbWFwXCIgXG4gICAgICAgIGlkPVwibWFwXCIgXG4gICAgICAgIHJlZj17bWFwUmVmfVxuICAgICAgICBzdHlsZT17eyBcbiAgICAgICAgICB3aWR0aDogJzEwMCUnLCBcbiAgICAgICAgICBoZWlnaHQ6ICcxMDB2aCcsIFxuICAgICAgICAgIG1pbkhlaWdodDogJzYwMHB4JyxcbiAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICB6SW5kZXg6IDFcbiAgICAgICAgfX1cbiAgICAgIC8+XG4gICAgICB7bG9hZGluZyAmJiAoXG4gICAgICAgIDxkaXYgc3R5bGU9e3tcbiAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICB0b3A6ICc1MCUnLFxuICAgICAgICAgIGxlZnQ6ICc1MCUnLFxuICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgtNTAlLCAtNTAlKScsXG4gICAgICAgICAgekluZGV4OiAxMDAwLFxuICAgICAgICAgIGJhY2tncm91bmQ6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOSknLFxuICAgICAgICAgIHBhZGRpbmc6ICcyMHB4JyxcbiAgICAgICAgICBib3JkZXJSYWRpdXM6ICc4cHgnLFxuICAgICAgICAgIGJveFNoYWRvdzogJzAgNHB4IDIwcHggcmdiYSgwLDAsMCwwLjMpJ1xuICAgICAgICB9fT5cbiAgICAgICAgICA8aDM+TG9hZGluZyBEaXNwYXRjaCBEYXRhYmFzZSBNYXAuLi48L2gzPlxuICAgICAgICAgIDxwPkZldGNoaW5nIHJvYWRzIGFuZCBsb2NhdGlvbnMuLi48L3A+XG4gICAgICAgIDwvZGl2PlxuICAgICAgKX1cbiAgICA8L2Rpdj5cbiAgKTtcbn1cblxuXG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJ1c2VRdWVyeSIsImdxbCIsIkdFVF9MT0NBVElPTlMiLCJHRVRfU0VHTUVOVFMiLCJNYXBDb21wb25lbnQiLCJsb2NhdGlvbnNEYXRhIiwic2VnbWVudHNEYXRhIiwibWFwUmVmIiwibWFwSW5zdGFuY2VSZWYiLCJtYXBJbml0aWFsaXplZFJlZiIsImRhdGEiLCJsb2FkaW5nIiwibG9jYXRpb25zTG9hZGluZyIsImVycm9yIiwibG9jYXRpb25zRXJyb3IiLCJmZXRjaFBvbGljeSIsImVycm9yUG9saWN5Iiwic2VnbWVudHNMb2FkaW5nIiwic2VnbWVudHNFcnJvciIsInZhcmlhYmxlcyIsImxpbWl0IiwicmVzZXRDb21wb25lbnRTdGF0ZSIsImN1cnJlbnQiLCJyZW1vdmUiLCJsb2FkTWFwIiwiTCIsImRlZmF1bHQiLCJtYXBDb250YWluZXIiLCJyZXRyaWVzIiwibWF4UmV0cmllcyIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJjb25zb2xlIiwibG9nIiwiX2xlYWZsZXRfaWQiLCJtYXAiLCJjZW50ZXIiLCJjcnMiLCJDUlMiLCJFUFNHMzg1NyIsInpvb20iLCJ6b29tQ29udHJvbCIsInByZWZlckNhbnZhcyIsIndpbmRvdyIsIm1fYmV6aWVyIiwidGlsZV9sYXllcl84NmFmNDExZmNhYTE0YjJlODkxNDQ2NmI1MjAwOTYzMyIsInRpbGVMYXllciIsIm1pblpvb20iLCJtYXhab29tIiwibWF4TmF0aXZlWm9vbSIsIm5vV3JhcCIsImF0dHJpYnV0aW9uIiwic3ViZG9tYWlucyIsImRldGVjdFJldGluYSIsInRtcyIsIm9wYWNpdHkiLCJhZGRUbyIsInRpbGVfbGF5ZXJfNjUxYzIxN2U5MTU5OWM3ODhjMWQyZjRkZGNlZTIyZWYiLCJ0aWxlX2xheWVyXzFhZWEwYTk0OTc4ZWNmNGQ3ZjFjZTAwOTZhNjkyNzQxIiwidGlsZV9sYXllcl9iZGIyNzhiZmQ3YmY0NWJkM2YxYjdlM2YxMmE2ZmRkMyIsInRpbGVfbGF5ZXJfZWY5MTVhYjkyZTBkZGNiOWU4NDA5NTVhOWQ0NDIwZjUiLCJ0aWxlX2xheWVyX2VjMGUyNjZkYWNkZDlhZTg3OTIxNTNlMDAyMDRmNDQwIiwidGlsZV9sYXllcl85ODBiNzY5MWIzOWFjZTg2ZjViYzVhOWIxYTczODM4OSIsInRpbGVfbGF5ZXJfNDM3OGI3NDQyNzJhMjJmNzhjMTRjOWU4MGI4MzBlYjgiLCJiYXNlTGF5ZXJzIiwibGF5ZXJDb250cm9sIiwiY29udHJvbCIsImxheWVycyIsInBvc2l0aW9uIiwiY29sbGFwc2VkIiwibGF5ZXJDb250cm9sRWxlbWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJpc0RyYWdnaW5nIiwiY3VycmVudFgiLCJjdXJyZW50WSIsImluaXRpYWxYIiwiaW5pdGlhbFkiLCJ4T2Zmc2V0IiwieU9mZnNldCIsImFkZEV2ZW50TGlzdGVuZXIiLCJkcmFnU3RhcnQiLCJkcmFnIiwiZHJhZ0VuZCIsImUiLCJ0YXJnZXQiLCJjbG9zZXN0IiwiY2xpZW50WCIsImNsaWVudFkiLCJjb250YWlucyIsInN0eWxlIiwiY3Vyc29yIiwicHJldmVudERlZmF1bHQiLCJ0cmFuc2Zvcm0iLCJjcmVhdGVFbGVtZW50IiwidGV4dENvbnRlbnQiLCJoZWFkIiwiYXBwZW5kQ2hpbGQiLCJpc1JpZ2h0Q2xpY2tpbmciLCJzdGFydFgiLCJzdGFydFkiLCJnZXRDb250YWluZXIiLCJib2R5IiwiZGVsdGFYIiwiZGVsdGFZIiwiYmVhcmluZ0NoYW5nZSIsInBpdGNoQ2hhbmdlIiwiY3VycmVudEJlYXJpbmciLCJnZXRCZWFyaW5nIiwibmV3QmVhcmluZyIsInNldEJlYXJpbmciLCJzZXRQaXRjaCIsImN1cnJlbnRQaXRjaCIsImdldFBpdGNoIiwibmV3UGl0Y2giLCJNYXRoIiwibWF4IiwibWluIiwibWFwUmVhZHkiLCJsb2NhdGlvbnMiLCJsZW5ndGgiLCJzZWdtZW50cyIsImVhY2hMYXllciIsImxheWVyIiwib3B0aW9ucyIsImlzRGF0YUxheWVyIiwiaXNMb2NhdGlvbkxheWVyIiwicmVtb3ZlTGF5ZXIiLCJzZWdtZW50c0FkZGVkIiwic2VnbWVudHNXaXRoR2VvbWV0cnkiLCJzZWdtZW50c1dpdGhvdXRHZW9tZXRyeSIsIm9wZW5TZWdtZW50Q291bnQiLCJjbG9zZWRTZWdtZW50Q291bnQiLCJmb3JFYWNoIiwic2VnbWVudCIsImluZGV4IiwibGFuZV9pZCIsImRpcmVjdGlvbiIsImlzX2Nsb3NlZCIsImdlb21ldHJ5IiwiZ2VvSnNvbiIsIkpTT04iLCJwYXJzZSIsImNvb3JkaW5hdGVzIiwic2xpY2UiLCJBcnJheSIsImlzQXJyYXkiLCJjb2xvciIsIndlaWdodCIsImxlYWZsZXRDb29yZHMiLCJjb29yZCIsInBvbHlsaW5lIiwiZmlsbE9wYWNpdHkiLCJwb3B1cCIsInJvYWRfaWQiLCJsZW5ndGhfbSIsInRvRml4ZWQiLCJzdGFydF9sYXRpdHVkZSIsInN0YXJ0X2xvbmdpdHVkZSIsImVuZF9sYXRpdHVkZSIsImVuZF9sb25naXR1ZGUiLCJiaW5kUG9wdXAiLCJsb2NhdGlvbnNBZGRlZCIsImdlbmVyYXRlTG9jYXRpb25UeXBlQ29sb3JzIiwibG9jYXRpb25UeXBlcyIsImNvbG9yUGFsZXR0ZSIsImNvbG9ycyIsInVzZWRDb2xvcnMiLCJTZXQiLCJ0eXBlIiwiY29sb3JJbmRleCIsImF0dGVtcHRzIiwiaGFzIiwiYWRkIiwidW5pcXVlTG9jYXRpb25UeXBlcyIsImxvYyIsInVuaXRfdHlwZSIsImZpbHRlciIsIkJvb2xlYW4iLCJsb2NhdGlvblR5cGVDb2xvcnMiLCJsb2NhdGlvbiIsImxvY2F0aW9uX25hbWUiLCJsYXRpdHVkZSIsImxvbmdpdHVkZSIsIm1hcmtlckNvbG9yIiwibWFya2VyIiwiY2lyY2xlTWFya2VyIiwicmFkaXVzIiwiZmlsbENvbG9yIiwibG9jYXRpb25fY2F0ZWdvcnkiLCJlbGV2YXRpb25fbSIsInBpdF9uYW1lIiwicmVnaW9uX25hbWUiLCJhbGxMYXRMbmdzIiwicHVzaCIsImJvdW5kcyIsImxhdExuZ0JvdW5kcyIsImZpdEJvdW5kcyIsInBhZGRpbmciLCJnZXRDZW50ZXIiLCJnZXRab29tIiwibGF0IiwibG5nIiwiYWRkU2ltcGxlTGVnZW5kIiwibG9jYXRpb25Db3VudCIsInNlZ21lbnRDb3VudCIsImV4aXN0aW5nTGVnZW5kIiwib3BlblJvYWRzIiwiY2xvc2VkUm9hZHMiLCJnZW5lcmF0ZUxlZ2VuZENvbG9ycyIsIk9iamVjdCIsImtleXMiLCJsZWdlbmRIdG1sIiwiZW50cmllcyIsInNvcnQiLCJhIiwiYiIsImNvdW50Iiwiam9pbiIsImxlZ2VuZEVsZW1lbnQiLCJpbm5lckhUTUwiLCJ0b2dnbGVTZWN0aW9uIiwiY29udGVudElkIiwiYXJyb3dJZCIsImNvbnRlbnQiLCJhcnJvdyIsImRpc3BsYXkiLCJ0b2dnbGVMZWdlbmQiLCJsZWdlbmQiLCJoZWFkZXIiLCJpZCIsImRpdiIsInRvcCIsImxlZnQiLCJ6SW5kZXgiLCJiYWNrZ3JvdW5kIiwiYm9yZGVyUmFkaXVzIiwiYm94U2hhZG93IiwiaDMiLCJwIiwid2lkdGgiLCJoZWlnaHQiLCJjbGFzc05hbWUiLCJyZWYiLCJtaW5IZWlnaHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/MapComponent.js\n"));

/***/ }),

/***/ "./node_modules/@swc/helpers/esm/_tagged_template_literal.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@swc/helpers/esm/_tagged_template_literal.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _: function() { return /* binding */ _tagged_template_literal; },\n/* harmony export */   _tagged_template_literal: function() { return /* binding */ _tagged_template_literal; }\n/* harmony export */ });\nfunction _tagged_template_literal(strings, raw) {\n    if (!raw) raw = strings.slice(0);\n\n    return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } }));\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL2VzbS9fdGFnZ2VkX3RlbXBsYXRlX2xpdGVyYWwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTztBQUNQOztBQUVBLDREQUE0RCxPQUFPLDZCQUE2QjtBQUNoRztBQUN5QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL2VzbS9fdGFnZ2VkX3RlbXBsYXRlX2xpdGVyYWwuanM/ZTM4NiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gX3RhZ2dlZF90ZW1wbGF0ZV9saXRlcmFsKHN0cmluZ3MsIHJhdykge1xuICAgIGlmICghcmF3KSByYXcgPSBzdHJpbmdzLnNsaWNlKDApO1xuXG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoc3RyaW5ncywgeyByYXc6IHsgdmFsdWU6IE9iamVjdC5mcmVlemUocmF3KSB9IH0pKTtcbn1cbmV4cG9ydCB7IF90YWdnZWRfdGVtcGxhdGVfbGl0ZXJhbCBhcyBfIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@swc/helpers/esm/_tagged_template_literal.js\n"));

/***/ })

}]);